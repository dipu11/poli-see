<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8"/>
<title>Privacy Poli-see</title>
<link rel="stylesheet" type="text/css" href="styles.css">
<link rel="icon" type="image/png" href="images/icon32.png">

</head>

<body>

<h1></h1>
<p></p>

<a class="tutorial_box" href="tutorial.html" target="_blank">
  <img src="images/tutorial.png" alt="tutorial icon">
  <h2 style="display:inline-block">Tutorial</h2>
</a>

<div class="visualization_box">
  <svg id="canvas">
    <defs></defs>
  </svg>

  <div id="node_panel_box" class="panel_box" style="display: none">
    <div id="node_panel" class="panel">
      <h1></h1>
      <p></p>
      <div id="node_panel_opts_box">
        <svg>
          <circle></circle>
        </svg>
        <div>
          <h2></h2>
          <p></p>
        </div>
      </div>
      <div id="node_panel_uses_box" class="panel_list_box">
        <h2></h2>
      </div>
      <span class="close_btn"></span>
    </div>
  </div>

  <div id="link_panel_box" class="panel_box" style="display: none">
    <svg id="link_panel_graphic">
      <polyline></polyline>
      <circle></circle>
      <circle></circle>
    </svg>
    <div id="link_panel" class="panel">
      <div id="link_panel_header_box">
        <svg>
          <circle></circle>
        </svg>
        <h1 style="display: inline-block"></h1>
      </div>
      <p></p>
      <span class="close_btn"></span>
    </div>
  </div>
</div>

<script src="d3/d3.min.js"></script>
<script>

// enumerated constants for some types of elements
const element_types =
{
  NODE: "node",
  LINK: "link",
  USE: "use"
}

const NUM_LAYERS = 3;
const OPTS_PAT_ID = "pat_opts";

// objects for policy- and visual-related data
var pol;
var vis;

// arrays for nodes and links
var nodes;
var links = [];

// arrays for node, link, and use types
var node_types;
var link_types;
var use_types;

// object for currently selected element
var clicked_elt = null;

// selection of svg to contain the main body of the graph
var svg_s = d3.select("#canvas");
// selection of g to be placed at center of the graph
var g_s = svg_s.append("g");

// selections of div containers for panels and related display elements
var node_panel_box_s = d3.select("#node_panel_box");
var link_panel_box_s = d3.select("#link_panel_box");

// selections of div panels to display additional information about nodes and links
var node_panel_s = node_panel_box_s.select("#node_panel");
var link_panel_s = link_panel_box_s.select("#link_panel");

// selections of divs to display information about options and uses in node panel
var node_panel_opts_box_s = node_panel_s.select("#node_panel_opts_box");
var node_panel_uses_box_s = node_panel_s.select("#node_panel_uses_box");

// selection of svg to display graphic above link panel
var link_panel_graphic_s = link_panel_box_s.select("#link_panel_graphic");

// selection of panel close buttons
var panel_close_btns_s = d3.selectAll(".close_btn");

// array containing radii of background circles
var bg_circles_rs;

// node-mapping object to generate tree
var root;
// D3 tree to organize nodes
var tree = d3.tree();

// selection of nodes to represent personal data
var nodes_s;
// selection of links to connect nodes
var links_s;

// central node
var central_node;
// array of primary nodes, direct successors of the central node in layer 1
var primary_nodes = [];
// array of links that should be drawn in the background
var bg_links = [];
// selection of links background links
var bg_links_s;



// return the node with a given id
function nodeById(id)
{
  return nodes.find(n => n.id == id);
}

// return the node type with a given id
function nodeTypeById(id)
{
  return node_types.find(t => t.id == id);
}

// return the link type with a given id
function linkTypeById(id)
{
  return link_types.find(t => t.id == id);
}

// return the use type with a given id
function useTypeById(id)
{
  return use_types.find(t => t.id == id);
}

// return the radius of a node
function nodeRadius(n)
{
  if(n.layer == 0)
  {
    return vis.node.central_node_r;
  }
  return vis.node.r;
}

// return a string containing the points for a link polyline arrow pointing down, given a link
function linkPoints(l)
{
  var source = nodeById(l.source);
  var dest = nodeById(l.dest);
  var len = linkLen(source.x, source.y, dest.x, dest.y, dest.r + vis.node.outline_width +
    vis.link.head_to_node_dist);
  return linkPointsFromLen(len);
}

// return the length of a link polyline arrow, given relevant values
function linkLen(source_x, source_y, dest_x, dest_y, subtract_len)
{
  return Math.sqrt( Math.pow((dest_x - source_x), 2) + Math.pow((dest_y - source_y), 2)) - subtract_len;
}

// return a string containing the points for a link polyline arrow pointing down, given its length
function linkPointsFromLen(len)
{
  var len_to_head = len - vis.link.head_len;
  var w1 = vis.link.width / 2;
  var w2 = vis.link.head_width / 2;
  return "0 0, " +
    w1 + " 0, " +
    w1 + " " + len_to_head + ", " +
    w2 + " " + len_to_head + ", " +
    "0 " + len + ", " +
    -w2 + " " + len_to_head + ", " +
    -w1 + " " + len_to_head + ", " +
    -w1 + " 0, 0 0";
}

// return the degrees by which a link needs to be rotated counterclockwise from pointing straight down in order to
// point in the right direction
function linkRotation(l)
{
  var source = nodeById(l.source);
  var dest = nodeById(l.dest);
  var theta = Math.atan2((source.y - dest.y), (source.x - dest.x));
  return theta * 180 / Math.PI + 90;
}

// return the color of a link
function linkColor(l)
{
  if(l.dest == pol.base_all_data_node_id)
  {
    return vis.link.color_bg;
  }
  else if(nodeById(l.dest).identifiable)
  {
    return vis.link.color_identifiable;
  }
  return vis.link.color_unidentifiable;
}

// return the color of a link, given its destination id
function linkColorByDestId(id)
{
  if(id == pol.base_all_data_node_id)
  {
    return vis.link.color_bg;
  }
  else if(nodeById(id).identifiable)
  {
    return vis.link.color_identifiable;
  }
  return vis.link.color_unidentifiable;
}

// return the fill color of a use type
function useTypeFillColor(t)
{
  if(t.unknown)
  {
    return vis.use_icon.fill_color_unknown;
  }
  else if(t.all_data)
  {
    return vis.node.fill_color_all_data;
  }
  return vis.use_icon.fill_color_normal;
}

// return the outline color of a node
function nodeOutlineColor(n)
{
  if(n.identifiable)
  {
    return vis.node.outline_color_identifiable;
  }
  return vis.node.outline_color_unidentifiable;
}

// return the outline color of a use type
function useTypeOutlineColor(t)
{
  if(t.all_data)
  {
    return nodeOutlineColor(nodeById(pol.base_all_data_node_id));
  }
  return vis.use_icon.outline_color;
}

// return the fill pattern of a node
function getNodePat(n)
{
  return n.identifiable ? "url(#pat_" + n.type + "_identifiable)"
                        : "url(#pat_" + n.type + "_unidentifiable)";
}

// return the icon fill pattern of a link
function getLinkPat(l)
{
  return nodeById(l.dest).identifiable ? "url(#pat_" + l.type + "_identifiable)"
                                       : "url(#pat_" + l.type + "_unidentifiable)";
}

// return the icon fill pattern of a link, given its type id
function getLinkPatByTypeId(id)
{
  return "url(#pat_" + id + ")";
}

// return the icon fill pattern of a use, given its type id
function getUsePatByTypeId(id)
{
  return "url(#pat_" + id + ")";
}

// return the fill pattern of an options icon
function getOptsPat()
{
  return "url(#" + OPTS_PAT_ID + ")";
}

// set up patterns to fill nodes, link icons, use icons, and other svg elements
function setUpPats()
{
  // node patterns
  var node_pats_identifiable = svg_s.select("defs").selectAll(".node_pat_identifiable")
    .data(node_types)
    .enter()
    .append("pattern")
      .attr("id", d => "pat_" + d.id + "_identifiable")
      .classed(".node_pat_identifiable", true)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  node_pats_identifiable.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.all_data ? vis.node.fill_color_all_data : vis.node.fill_color_identifiable);
  node_pats_identifiable.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image_identifiable);

  var node_pats_unidentifiable = svg_s.select("defs").selectAll(".node_pat_unidentifiable")
    .data(node_types)
    .enter()
    .append("pattern")
      .attr("id", d => "pat_" + d.id + "_unidentifiable")
      .classed(".node_pat_unidentifiable", true)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  node_pats_unidentifiable.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.all_data ? vis.node.fill_color_all_data : vis.node.fill_color_unidentifiable);
  node_pats_unidentifiable.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image_unidentifiable);

  // link patterns
  var link_pats_identifiable = svg_s.select("defs").selectAll(".link_pat_identifiable")
    .data(link_types)
    .enter()
    .append("pattern")
      .attr("id", d => "pat_" + d.id + "_identifiable")
      .classed(".link_pat_identifiable", true)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  link_pats_identifiable.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.all_data ? vis.node.fill_color_all_data : vis.link.color_identifiable);
  link_pats_identifiable.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image_identifiable);

  var link_pats_unidentifiable = svg_s.select("defs").selectAll(".link_pat_unidentifiable")
    .data(link_types)
    .enter()
    .append("pattern")
      .attr("id", d => "pat_" + d.id + "_unidentifiable")
      .classed(".link_pat_unidentifiable", true)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  link_pats_unidentifiable.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.all_data ? vis.node.fill_color_all_data : vis.link.color_unidentifiable);
  link_pats_unidentifiable.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image_unidentifiable);

  // use icon patterns
  var use_pats = svg_s.select("defs").selectAll(".use_pat")
    .data(use_types)
    .enter()
    .append("pattern")
      .attr("id", d => "pat_" + d.id)
      .classed(".use_pat", true)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  use_pats.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", useTypeFillColor);
  use_pats.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image);

  // options icon pattern
  var opts_pat = svg_s.select("defs").append("pattern")
    .attr("id", OPTS_PAT_ID)
    .attr("width", "1")
    .attr("height", "1")
    .attr("patternContentUnits", "objectBoundingBox");
  opts_pat.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", vis.opts_node_icon.fill_color);
  opts_pat.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", vis.opts_icon.image);
}

// helper function to recursively create a stick with the child at the bottom and num_ancestors ancestors
function makeStick(child, num_ancestors)
{
  return num_ancestors <= 0 ? child
                            : makeStick({ id: null, children: [child] }, num_ancestors - 1);
}

// recursively create a tree, given the root
function makeTree(root)
{
  // make a copy of the root's successor links
  var successor_links = root.successor_links.slice();

  // if there are no successor links, then return the root as a leaf
  if(successor_links.length == 0)
  {
    return { id: root.id, children: [], siblings: [] };
  }
  // else if there are successor links, then return the root's branch
  else
  {
    var children = [];
    var siblings = [];

    // iterate through successor links
    for(var i = 0; i < successor_links.length; i++)
    {
      var s = nodeById(successor_links[i].successor_id);
      var s_branch = makeTree(s);

      // if the successor is in a higher layer than the root, then add it as a child
      if(s.layer > root.layer)
        children.push(makeStick(s_branch, s.layer - root.layer - 1));
      // else if the successor is in the same layer as the root, then add it as a sibling
      else if(s.layer == root.layer)
        siblings.push(makeTree(s));

      // add the successor's siblings as children of the root
      for(var j = 0; j < s_branch.siblings.length; j++)
      {
        children.push(makeStick(s_branch.siblings[j], s.layer - root.layer - 1));
      }
    }

    // return a tree
    return { id: root.id, children: children, siblings: siblings };
  }
}

// update the node panel based on a node
function updateNodePanel(n)
{
  // set color of panel based on whether data is identifiable or not
  var fill_color;
  var outline_color;
  if(n.identifiable)
  {
    fill_color = vis.node_panel.fill_color_identifiable;
    outline_color = vis.node_panel.outline_color_identifiable;
  }
  else
  {
    fill_color = vis.node_panel.fill_color_unidentifiable;
    outline_color = vis.node_panel.outline_color_unidentifiable;
  }
  node_panel_s
    .style("background-color", fill_color)
    .style("border-color", outline_color);


  // set basic panel text
  node_panel_s.select("h1")
    .html(n.label);
  node_panel_s.select("p")
    .html(n.text);

  // set information about options regarding the node
  if(n.opts)
  {
    node_panel_opts_box_s.select("p")
      .html(n.opts_text);
    node_panel_opts_box_s.style("display", "flex");
  }
  else
  {
    node_panel_opts_box_s.style("display", "none");
  }

  // combine uses and links into one array, used to display how data can be used
  var display_uses = [];
  // list to prevent the same types of links from being displayed multiple times
  var track_links = [];
  for(let i = 0; i < n.uses.length; i++)
  {
    display_uses.push({type:n.uses[i], elt_type:element_types.USE});
  }
  for(let i = 0; i < n.successor_links.length; i++)
  {
    if(! track_links.includes(n.successor_links[i].type))
    {
      display_uses.push(n.successor_links[i]);
      display_uses[display_uses.length - 1].elt_type = element_types.LINK;
      track_links.push(n.successor_links[i].type);
    }
  }

  // if there are no uses to display, then hide the section
  if(n.layer == 0 || display_uses.length == 0)
  {
    node_panel_uses_box_s
      .style("display", "none");
  }
  // if there are uses to display, then display them
  else
  {
    node_panel_uses_box_s
      .style("display", "block");

    // update the heading
    node_panel_uses_box_s.select("h2")
      .html(n.data_handler + " can use this data to...");

    // remove existing use divs
    node_panel_uses_box_s.selectAll("div").remove();

    // add use divs to the panel
    var use_divs_s = node_panel_uses_box_s.selectAll("div")
      .data(display_uses)
      .enter().append("div")
        .classed("panel_list_item_box", true)
        .style("border-bottom", vis.node_panel.outline_width + "px solid " + outline_color);

    // remove bottom border from last use div
    node_panel_uses_box_s.select("div:last-child")
      .style("border-bottom", "none");

    // add icons and text to the use divs
    var icon_r_full = vis.use_icon.r + vis.use_icon.outline_width;
    var use_divs_svgs_s = use_divs_s.append("svg")
      .attr("height", icon_r_full * 2 + "px");
    var use_divs_use_svgs_s = use_divs_svgs_s.filter(d => d.elt_type == element_types.USE);
    var use_divs_link_svgs_s = use_divs_svgs_s.filter(d => d.elt_type == element_types.LINK);

    use_divs_use_svgs_s
      .style("flex-basis", d => useTypeById(d.type).all_data ? icon_r_full * 5 + "px"
                                                             : icon_r_full * 2 + "px");
    use_divs_link_svgs_s
      .style("flex-basis", icon_r_full * 5 + "px");

    use_divs_use_svgs_s.append("circle")
      .attr("r", vis.use_icon.r)
      .attr("cx", d => useTypeById(d.type).all_data ? 4 * icon_r_full : icon_r_full)
      .attr("cy", icon_r_full)
      .attr("fill", d => useTypeById(d.type).all_data ? getNodePat(nodeById(pol.base_all_data_node_id))
                                                      : getUsePatByTypeId(d.type))
      .attr("stroke", d => useTypeOutlineColor(useTypeById(d.type)))
      .attr("stroke-width", vis.use_icon.outline_width);
    use_divs_link_svgs_s.append("circle")
      .attr("r", vis.use_icon.r)
      .attr("cx", 4 * icon_r_full)
      .attr("cy", icon_r_full)
      .attr("fill", d => getNodePat(nodeById(d.successor_id)))
      .attr("stroke", d => nodeOutlineColor(nodeById(d.successor_id)))
      .attr("stroke-width", vis.use_icon.outline_width);

    use_divs_use_svgs_s.filter(d => useTypeById(d.type).all_data).append("polyline")
      .attr("transform", "translate(" + 0 + "," + icon_r_full + ") rotate(270)")
      .attr("points", linkPointsFromLen(linkLen(0, icon_r_full, 4 * icon_r_full, icon_r_full,
        icon_r_full + vis.link.head_to_node_dist)))
      .attr("fill", vis.link.color_bg_highlight)
      .attr("stroke-width", 0);
    use_divs_link_svgs_s.append("polyline")
      .attr("transform", "translate(" + 0 + "," + icon_r_full + ") rotate(270)")
      .attr("points", linkPointsFromLen(linkLen(0, icon_r_full, 4 * icon_r_full, icon_r_full,
        icon_r_full + vis.link.head_to_node_dist)))
      .attr("fill", d => linkColorByDestId(d.successor_id))
      .attr("stroke-width", 0);

    // add icons for special types of links
    use_divs_link_svgs_s.filter(d => linkTypeById(d.type).display_on_link).append("circle")
      .attr("transform", function(d)
      {
        let len_to_head = linkLen(0, icon_r_full, 4 * icon_r_full, icon_r_full,
          icon_r_full + vis.link.head_to_node_dist) - vis.link.head_len;
        return "translate(" + len_to_head/2 + "," + icon_r_full + ")";
      })
      .attr("r", vis.link_icon_on_link.r)
      .attr("fill", d => nodeById(d.successor_id).identifiable ? getLinkPatByTypeId(d.type + "_identifiable")
                                                               : getLinkPatByTypeId(d.type + "_unidentifiable"))
      .attr("stroke", d => linkColorByDestId(d.successor_id))
      .attr("stroke-width", vis.link_icon.outline_width);

    use_divs_s.filter(d => d.elt_type == element_types.USE).append("p")
      .html(d => useTypeById(d.type).description);
    use_divs_s.filter(d => d.elt_type == element_types.LINK).append("p")
      .html(d => linkTypeById(d.type).description);
  }

  // show the panel
  node_panel_box_s
    .style("display", "inline-block");
}

// update the link panel based on a link
function updateLinkPanel(l)
{
  var source = nodeById(l.source);
  var dest = nodeById(l.dest);

  // set color of panel based on whether data of destination node is identifiable or not
  var fill_color;
  var outline_color;
  if(dest.identifiable)
  {
    fill_color = vis.link_panel.fill_color_identifiable;
    outline_color = vis.link_panel.outline_color_identifiable;
  }
  else
  {
    fill_color = vis.link_panel.fill_color_unidentifiable;
    outline_color = vis.link_panel.outline_color_unidentifiable;
  }
  link_panel_s
    .style("background-color", fill_color)
    .style("border-color", outline_color);

  var node_r_full = vis.node.r + vis.node.outline_width;

  // update the link graphic
  link_panel_graphic_s.select("polyline")
      .attr("points", linkPointsFromLen(linkLen(node_r_full, node_r_full,
        vis.link_panel_graphic.dist_between_nodes + node_r_full, node_r_full,
        node_r_full + vis.link.head_to_node_dist)))
      .attr("fill", linkColor(l));
  link_panel_graphic_s.select("circle")
      .attr("fill", getNodePat(source))
      .attr("stroke", nodeOutlineColor(source));
  link_panel_graphic_s.select("circle:nth-child(3)")
      .attr("fill", getNodePat(dest))
      .attr("stroke", nodeOutlineColor(dest));

  // set the icon and title for the link panel
  link_panel_s.select("circle")
    .attr("fill", getLinkPat(l))
    .attr("stroke", dest.id == pol.base_all_data_node_id ? nodeOutlineColor(nodeById(pol.base_all_data_node_id))
                                                         : linkColor(l));
  link_panel_s.select("h1")
    .html(linkTypeById(l.type).label);
  link_panel_s.select("p")
    .html(l.text);

  // show the panel
  link_panel_box_s
    .style("display", "inline-block");
}

// update either the node or the link panel, based on an input element
function updatePanel(elt)
{
  if(elt.type == element_types.NODE)
  {
    updateNodePanel(elt.data);
  }
  else if(elt.type == element_types.LINK)
  {
    updateLinkPanel(elt.data);
  }
}

// hide the panels
function hidePanels()
{
  node_panel_box_s
    .style("display", "none");
  link_panel_box_s
    .style("display", "none");
}

// if the input element is a node, then gradually increase its radius to 1.3 times its normal value
function increaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.s.select("circle")
      .transition()
      .attr("r", elt.data.r * 1.3);
  }
}

// if the input element is a node, then gradually decrease its radius to its normal value
function decreaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.s.select("circle")
      .transition()
      .attr("r", elt.data.r);
  }
}

// change the input element's outline to indicate focus
function focusElementOutline(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.s.select("circle")
      .attr("stroke", vis.node.outline_color_focus)
      .attr("stroke-width", vis.node.outline_width_focus);
  }
  else
  {
    elt.s.select("polyline")
      .attr("stroke-width", vis.link.outline_width_focus);
  }
}

// change the input element's outline to not indicate focus
function unfocusElementOutline(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.s.select("circle")
      .attr("stroke", nodeOutlineColor)
      .attr("stroke-width", vis.node.outline_width);
  }
  else if(clicked_elt.type == element_types.LINK)
  {
    clicked_elt.s.select("polyline")
      .attr("stroke-width", 0);
  }
}

// highlight a node's background arrow, if it has one
function highlightBgArrow(elt)
{
  var a = bg_links_s.filter(d => d.source == elt.data.id);
  a.select("polyline")
    .attr("fill", vis.link.color_bg_highlight);

  // bring the highlighted arrow in front of other background arrows
  a.raise();
}

// unhighlight a node's background arrow, if it has one
function unhighlightBgArrow(elt)
{
  bg_links_s.filter(d => d.source == elt.data.id).select("polyline")
    .attr("fill", vis.link.color_bg);
}

// handle interactions when the cursor enters an interactive element
function onMouseEnter(elt)
{
  // display the correct panel
  hidePanels();
  updatePanel(elt);

  // if the cursor is over a node, then change its appearance
  if(elt.type == element_types.NODE)
  {
    increaseNodeRadius(elt);
    highlightBgArrow(elt);
  }
}

// handle interactions when the cursor leaves an interactive element
function onMouseLeave(elt)
{
  // hide the panel
  hidePanels();

  // if there is no clicked element, then if the cursor was over a node, then change its appearance back
  if(clicked_elt == null)
  {
    if(elt.type == element_types.NODE)
    {
      decreaseNodeRadius(elt);
      unhighlightBgArrow(elt);
    }
  }
  // if there is a clicked element, then update the panel to display information about the clicked element
  else
  {
    updatePanel(clicked_elt);

    // if the cursor was over a node, then unless the node is the clicked element, change its appearance back
    if(elt.data.id != clicked_elt.data.id)
    {
      if(elt.type == element_types.NODE)
      {
        decreaseNodeRadius(elt);
        unhighlightBgArrow(elt);
      }
    }
  }
}

// handle interactions when the cursor clicks on an interactive element
function onClick(elt)
{
  // if there is no old clicked element, then focus on the new clicked element
  if(clicked_elt == null)
  {
    // change the outline of the new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if there is an old clicked element that is not the new clicked element, then focus away from the old and on the new
  else if(elt.data.id != clicked_elt.data.id)
  {
    // display the correct panel
    hidePanels();
    updatePanel(elt);

    // change the outline of the old clicked element back to normal, and change its appearance otherwise back
    unfocusElementOutline(clicked_elt);
    if(clicked_elt.type == element_types.NODE)
    {
      decreaseNodeRadius(clicked_elt);
      unhighlightBgArrow(clicked_elt);
    }

    // change outline of new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if the new clicked element is the old clicked element, then focus away from it
  else
  {
    // change outline of clicked element back to normal
    unfocusElementOutline(elt);

    clicked_elt = null;
  }
}



function main()
{
  // set title and intro text
  d3.select("h1").html(pol.title);
  d3.select("p").html(pol.intro);

  // set up patterns for background fills
  setUpPats();

  // set display variables and elements
  {
    let display_r = vis.display.r;

    let node_r_full = vis.node.r + vis.node.outline_width;
    let link_icon_r_full = vis.link_icon.r + vis.link_icon.outline_width;
    let opts_panel_icon_r_full = vis.opts_panel_icon.r + vis.opts_panel_icon.outline_width;

    let node_panel_extra_space = 2 * (vis.node_panel.padding + vis.node_panel.outline_width);
    let node_panel_max_height = 2 * display_r - node_panel_extra_space;

    let link_panel_graphic_height = 2 * node_r_full;
    let link_panel_extra_space = 2 * (vis.link_panel.padding + vis.link_panel.outline_width);
    let link_panel_max_height = 2 * display_r - link_panel_extra_space - link_panel_graphic_height -
      vis.link_panel_graphic.margin_bottom;

    bg_circles_rs = vis.bg_circle.r_proportions.map(function(x) { return x * display_r; });
    svg_s
      .attr("width", 2 * display_r)
      .attr("height", 2 * display_r);
    g_s.attr("transform", "translate(" + display_r + "," + display_r + ")");

    node_panel_s
      .style("border", vis.node_panel.outline_width + "px solid")
      .style("width", vis.node_panel.width + "px")
      .style("max-height", node_panel_max_height + "px")
      .style("padding", vis.node_panel.padding + "px");

    node_panel_opts_box_s.select("svg")
      .attr("width", 2 * opts_panel_icon_r_full)
      .attr("height", 2 * opts_panel_icon_r_full);
    node_panel_opts_box_s.select("h2")
      .html("You have some control over this data.");
    node_panel_opts_box_s.select("circle")
      .attr("cx", opts_panel_icon_r_full)
      .attr("cy", opts_panel_icon_r_full)
      .attr("r", vis.opts_panel_icon.r)
      .attr("fill", getOptsPat())
      .attr("stroke", vis.opts_panel_icon.outline_color)
      .attr("stroke-width", vis.opts_panel_icon.outline_width);

    link_panel_s
      .style("border", vis.link_panel.outline_width + "px solid")
      .style("width", vis.link_panel.width + "px")
      .style("max-height", link_panel_max_height + "px")
      .style("padding", vis.link_panel.padding + "px");

    link_panel_graphic_s
      .attr("width", (vis.link_panel_graphic.dist_between_nodes + 2 * node_r_full) + "px")
      .attr("height", link_panel_graphic_height)
      .style("margin-bottom", vis.link_panel_graphic.margin_bottom);
    link_panel_graphic_s.select("polyline")
      .attr("transform", "translate(" + node_r_full + "," + node_r_full + ") rotate(270)")
      .attr("stroke-width", 0);
    link_panel_graphic_s.select("circle")
      .attr("r", vis.node.r)
      .attr("cx", node_r_full)
      .attr("cy", node_r_full)
      .attr("stroke-width", vis.node.outline_width);
    link_panel_graphic_s.select("circle:nth-child(3)")
      .attr("r", vis.node.r)
      .attr("cx", vis.link_panel_graphic.dist_between_nodes + node_r_full)
      .attr("cy", node_r_full)
      .attr("stroke-width", vis.node.outline_width);

    link_panel_s.select("svg")
      .attr("width", 2 * link_icon_r_full)
      .attr("height", 2 * link_icon_r_full)
      .select("circle")
        .attr("r", vis.link_icon.r)
        .attr("cx", link_icon_r_full)
        .attr("cy", link_icon_r_full)
        .attr("stroke-width", vis.link_icon.outline_width);

    tree
      .size([(2 - vis.layer_title.space_in_pi_radians) * Math.PI, display_r])
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
  }



  // iterate through nodes to record special nodes, change node layers to essentially create a second sub-layer in
  // layer 1, and create links and background links
  for(let i = 0; i < nodes.length; i++)
  {
    let n = nodes[i];

    // if the node is the central node, record it, and add its successor links in layer 1 to the array of primary nodes
    if(n.layer == 0)
    {
      central_node = n;
      for(let j = 0; j < n.successor_links.length; j++)
      {
        let s = nodeById(n.successor_links[j].successor_id);
        if(s.layer == 1)
        {
          primary_nodes.push(s);
        }
      }
    }

    // set the radius of the node
    n.r = nodeRadius(n);

    // fill links array with link objects based on the .json data
    for(let j = 0; j < n.successor_links.length; j++)
    {
      let l = n.successor_links[j];
      if(l.successor_id != pol.base_all_data_node_id)
      {
        links.push({ id: n.id + "->" + l.successor_id, source: n.id, dest: l.successor_id, type: l.type,
          text: l.text });
      }
    }

    // if the node is in layer one and not an all_data node, add a background link to the base all_data node
    if(n.layer == 1 && ! n.all_data)
    {
      bg_links.push({ id: n.id + "->" + pol.base_all_data_node_id, source: n.id,
        dest: pol.base_all_data_node_id, type: "link_all_data",
        text: "These lighter-colored arrows point to a circle representing all your data that " +
        pol.provider_name + " collects. Follow the arrow to that circle to see what " +
        pol.provider_name + " can do with all data it collects." });
    }

    // move the node one node outward to accommodate for second sub-layer within layer 1 (center node and primary
    // nodes will later be moved back)
    n.layer += 1;
  }

  // move central node and primary nodes back to their original layer
  central_node.layer -= 1;
  primary_nodes.map(n => n.layer -= 1);



  // map nodes and create a d3 tree
  root = tree(d3.hierarchy(makeTree(central_node)));
  tree_nodes = root.descendants();

  // set the coordinates of nodes to the coordinates of nodes in the tree, altered to make a radial tree
  for(let i = 0; i < nodes.length; i++)
  {
    let n = nodes[i];
    let offset = vis.layer_title.space_in_pi_radians / 2 * Math.PI;
    let tree_n = tree_nodes.find(function(node) { return node.data.id == n.id; });
    n.x = (tree_n.y = +tree_n.y) * Math.cos((tree_n.x -= Math.PI / 2) + offset);
    n.y = tree_n.y * Math.sin(tree_n.x + offset);

    // adjust the distance of nodes from the center, according to specified dimensions
    if(n.layer != 0)
    {
      n.x = n.x * vis.node.dist_from_center_proportions[n.layer] / (n.layer / NUM_LAYERS);
      n.y = n.y * vis.node.dist_from_center_proportions[n.layer] / (n.layer / NUM_LAYERS);
    }
  }



  // append background circles for layers
  for(let i = NUM_LAYERS - 1; i > 0; i--)
  {
    let r = bg_circles_rs[i];

    g_s.append("circle")
      .attr("r", r)
      .attr("fill", vis.bg_circle.fill_color)
      .attr("stroke", vis.bg_circle.outline_color)
      .attr("stroke-width", vis.bg_circle.outline_width);

    let r_for_text = r - vis.layer_title.font_size - vis.layer_title.dist_from_edge;
    let text = i == 2 ? "Third parties" : pol.provider_name;

    g_s.append("path")
      .attr("id", "text_layer_" + i)
      .attr("d", "M-" + r_for_text + ",0 a" + r_for_text + "," + r_for_text + " 0 0 1 " + (2 * r_for_text) + ",0")
      .attr("fill", "none");
    g_s.append("text")
      .classed("layer_title", true)
      .attr("text-anchor", "middle")
      .style("font-size", vis.layer_title.font_size + "px")
      .style("fill", vis.layer_title.color)
      .append("textPath")
        .html(text)
        .attr("xlink:href", "#text_layer_" + i)
        .attr("startOffset", "50%");
  }



  // append background links
  bg_links_s = g_s.append("g").selectAll(".bg_link")
    .data(bg_links)
    .enter().append("g")
      .classed("bg_link", true)
      .attr("transform", function(d)
      {
        let source = nodeById(d.source);
        return "translate(" + source.x + "," + source.y + ")";
      });

  // add lines to background links
  bg_links_s.append("polyline")
    .attr("points", linkPoints)
    .attr("transform", function(d) { return "rotate(" + linkRotation(d) + ")"; })
    .attr("fill", vis.link.color_bg)
    .attr("stroke", vis.link.outline_color_focus)
    .attr("stroke-width", 0);

  // mouse interactions for background links
  bg_links_s
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.LINK, data:d, s:d3.select(this)});
      d3.select(this).raise();
    })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.LINK, data:d, s:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.LINK, data:d, s:d3.select(this)}); });



  // append links
  links_s = g_s.append("g").selectAll(".link")
    .data(links)
    .enter().append("g")
      .classed("link", true)
      .attr("transform", function(d)
      {
        let source = nodeById(d.source);
        return "translate(" + source.x + "," + source.y + ") rotate(" + linkRotation(d) + ")";
      });

  // add lines to links
  links_s.append("polyline")
    .attr("points", linkPoints)
    .attr("fill", linkColor)
    .attr("stroke", vis.link.outline_color_focus)
    .attr("stroke-width", 0);

  // add icons for special types of links
  links_s.filter(d => linkTypeById(d.type).display_on_link).append("circle")
    .attr("transform", function(d)
    {
      let source = nodeById(d.source);
      let dest = nodeById(d.dest);
      let len_to_head = linkLen(source.x, source.y, dest.x, dest.y, dest.r + vis.node.outline_width +
        vis.link.head_to_node_dist) - vis.link.head_len;
      let displacement = (len_to_head + source.r) / 2;
      return "translate(0," + displacement + ") rotate(" + (-linkRotation(d)) + ")";
    })
    .attr("r", vis.link_icon_on_link.r)
    .attr("fill", getLinkPat)
    .attr("stroke", linkColor)
    .attr("stroke-width", vis.link_icon.outline_width);

  // mouse interactions for links
  links_s
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.LINK, data:d, s:d3.select(this)});
      d3.select(this).raise();
    })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.LINK, data:d, s:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.LINK, data:d, s:d3.select(this)}); });



  // append nodes
  nodes_s = g_s.append("g").selectAll(".node")
    .data(nodes)
    .enter().append("g")
      .classed("node", true)
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  // give the base all_data node an id
  nodes_s.filter(d => d.id == pol.base_all_data_node_id)
    .attr("id", pol.base_all_data_node_id)

  // add circles to nodes
  nodes_s.append("circle")
    .attr("r", nodeRadius)
    .attr("fill", getNodePat)
    .attr("stroke", nodeOutlineColor)
    .attr("stroke-width", vis.node.outline_width);

  // add options icon to nodes that contain options
  nodes_s.filter(d => d.opts == true).append("circle")
    .attr("cx", vis.opts_node_icon.cx)
    .attr("cy", vis.opts_node_icon.cy)
    .attr("r", vis.opts_node_icon.r)
    .attr("fill", getOptsPat())
    .attr("stroke", vis.opts_node_icon.outline_color)
    .attr("stroke-width", vis.opts_node_icon.outline_width);

  // mouse interactions for nodes
  nodes_s
    // display more information in the node panel when the cursor hovers over nodes
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.NODE, data:d, s:d3.select(this)});
      d3.select(this).raise();
    })
    // update the node panel when the cursor leaves a node
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.NODE, data:d, s:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.NODE, data:d, s:d3.select(this)}); });



  // mouse interactions for panel close buttons
  panel_close_btns_s
    .on("click", function(d)
    {
      let c = clicked_elt;
      onClick(c);
      onMouseLeave(c);
    });
}



// load data from .json files
var url = new URL(document.URL);
var p = url.searchParams.get("policy");
var v = url.searchParams.get("visual");
if(v == null)
{
  v = "default.json";
}

d3.json("data/policies/" + p).then(function(policy_json)
{
  d3.json("data/visual_customizations/" + v).then(function(visual_json)
  {
    // copy data from .json files
    pol = policy_json;
    vis = visual_json;

    nodes = pol.nodes;
    node_types = pol.node_types;
    link_types = pol.link_types;
    use_types = pol.use_types;

    main();
  });
});

</script>

</body>
</html>
