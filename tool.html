<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8"/>
<title>Privacy Poli-see</title>
<link rel="stylesheet" type="text/css" href="styles.css">
<link rel="icon" type="image/png" href="images/icon32.png">

</head>

<body>

<h1></h1>
<p></p>

<div class="tool_container">
  <svg id="canvas">
    <defs id="node_pattern_defs"></defs>
    <defs id="link_pattern_defs"></defs>
    <defs id="use_pattern_defs"></defs>
    <defs id="other_pattern_defs"></defs>
  </svg>

  <div id="node_sidebar_container" class="sidebar_container" style="display: none">
    <div id="node_sidebar" class="sidebar">
      <h1></h1>
      <p></p>
      <div id="node_sidebar_options_container">
        <svg>
          <circle></circle>
        </svg>
        <div>
          <h2></h2>
          <p></p>
        </div>
      </div>
      <div id="node_sidebar_uses_container" class="sidebar_list_container">
        <h2></h2>
      </div>
      <span class="close_button"></span>
    </div>
  </div>

  <div id="link_sidebar_container" class="sidebar_container" style="display: none">
    <svg id="link_sidebar_graphic">
      <polyline></polyline>
      <circle></circle>
      <circle></circle>
    </svg>
    <div id="link_sidebar" class="sidebar">
      <div id="link_sidebar_header_container">
        <svg>
          <circle></circle>
        </svg>
        <h1 style="display: inline-block"></h1>
      </div>
      <p></p>
      <span class="close_button"></span>
    </div>
  </div>
</div>

<script src="d3/d3.min.js"></script>
<script>

// enumerated constants for types of elements
const element_types =
{
  NODE: "node",
  LINK: "link"
}

// enumerated constants for types of uses displayed in node sidebar
const display_use_types =
{
  USE: "use",
  LINK: "link"
}

const NUM_LAYERS = 3;

// variables for title, intro text, name of the primary data-collecting entity, and options icon image
var title;
var intro_text;
var primary_entity_name;
var options_icon_image;

// arrays for nodes and links
var nodes;
var links = [];

// arrays for node, link, and use types
var node_types;
var link_types;
var use_types;

// object for appearance-related data
var appearance;

// object for currently selected element
var clicked_elt = null;

// selection of svg to contain the main body of the graph
var svg_selection = d3.select("#canvas");
// selection of g to be placed at center of the graph
var g_selection = svg_selection.append("g");

// selections of div containers to contain sidebars and potentially other display elements accompanying sidebars
var node_sidebar_container_selection = d3.select("#node_sidebar_container");
var link_sidebar_container_selection = d3.select("#link_sidebar_container");

// selections of div sidebars to display additional information about nodes and links
var node_sidebar_selection = node_sidebar_container_selection.select("#node_sidebar");
var link_sidebar_selection = link_sidebar_container_selection.select("#link_sidebar");

// selection of div for node options information
var node_sidebar_options_container_selection = node_sidebar_selection.select("#node_sidebar_options_container");

// selections of divs for uses
var node_sidebar_uses_container_selection = node_sidebar_selection.select("#node_sidebar_uses_container");

// selection of svg for link sidebar graphic
var link_sidebar_graphic_selection = link_sidebar_container_selection.select("#link_sidebar_graphic");

// selection of sidebar close buttons
var sidebar_close_buttons_selection = d3.select(".close_button");

// radii of background circles
var background_circles_radii;

// node-mapping object to generate tree
var root;

// D3 tree to organize nodes
var tree = d3.tree();

// icon fill patterns
var node_patterns;
var link_patterns;
var use_patterns;
var other_patterns;

// selection of nodes to represent personal data
var nodes_selection;

// selection of links to connect nodes
var links_selection;

// central node
var central_node;
// array of primary nodes, direct successors of the central node in layer 1
var primary_nodes = [];
// id of the base node containing all data collected
var base_all_data_node_id;
// array of links that should be drawn in the background
var background_links = [];
// selection of links background links
var background_links_selection;



// return the node with a given id
function getNodeById(id)
{
  return nodes.find(function(n) { return n.id == id; });
}

// return the node type with a given id
function getNodeTypeById(id)
{
  return node_types.find(function(t) { return t.id == id; });
}

// return the link type with a given id
function getLinkTypeById(id)
{
  return link_types.find(function(t) { return t.id == id; });
}

// return the use type with a given id
function getUseTypeById(id)
{
  return use_types.find(function(t) { return t.id == id; });
}

// given a use type, return the fill color
function getUseTypeFillColor(u)
{
  if(u.unknown)
  {
    return appearance.use_icon.fill_color_unknown;
  }
  else if(u.all_data)
  {
    return appearance.node.fill_color_all_data;
  }
  return appearance.use_icon.fill_color_normal;
}

// given a use type, return the outline color
function getUseTypeOutlineColor(u)
{
  if(u.all_data)
  {
    return appearance.node.outline_color_identifiable;
  }
  return appearance.use_icon.outline_color;
}

// return the proper fill pattern of a node
function getNodePattern(n)
{
  var url = "#" + n.type;

  if(n.identifiable)
    url += "_identifiable";
  else
    url += "_unidentifiable";

  return "url(" + url + ")";
}

// return the proper icon fill pattern of a link
function getLinkPattern(l)
{
  var id = l.type;

  if(getNodeById(l.destination).identifiable)
    id += "_identifiable";
  else
    id += "_unidentifiable";

  return getLinkPatternById(id);
}

// return the proper icon fill pattern of a link, given its id
function getLinkPatternById(id)
{
  var url = "#" + id;

  return "url(" + url + ")";
}

// return the proper icon fill pattern of a use, given its id
function getUsePatternById(id)
{
  var url = "#" + id;

  return "url(" + url + ")";
}

// return the outline color of a node
function getNodeOutlineColor(n)
{
  if(n.identifiable)
  {
    return appearance.node.outline_color_identifiable;
  }
  return appearance.node.outline_color_unidentifiable;
}

// return the radius of a node
function getNodeRadius(n)
{
  if(n.layer == 0)
  {
    return appearance.node.central_node_radius;
  }
  return appearance.node.radius;
}

// return the fill color of a link
function getLinkFillColor(l)
{
  if(l.destination == base_all_data_node_id)
  {
    return appearance.link.fill_color_background;
  }
  else if(getNodeById(l.destination).identifiable)
  {
    return appearance.link.fill_color_identifiable;
  }
  return appearance.link.fill_color_unidentifiable;
}

// return a string containing the points for a link polyline arrow pointing down, given a link
function getLinkPolylinePoints(l)
{
  var source = getNodeById(l.source);
  var dest = getNodeById(l.destination);
  var length = getLinkPolylineLength(source.x, source.y, dest.x, dest.y,
    dest.radius + appearance.node.outline_width + appearance.link.arrowhead_to_node_distance);
  return getLinkPolylinePointsFromLength(length);
}

// return the length of a link polyline arrow, given relevant values
function getLinkPolylineLength(source_x, source_y, dest_x, dest_y, subtract_len)
{
  return Math.sqrt( Math.pow((dest_x - source_x), 2) + Math.pow((dest_y - source_y), 2)) - subtract_len;
}

// return a string containing the points for a link polyline arrow pointing down, given its length
function getLinkPolylinePointsFromLength(length)
{
  var length_to_head = length - appearance.link.arrowhead_length;
  var w1 = appearance.link.width / 2;
  var w2 = appearance.link.arrowhead_width / 2;
  return "0 0, " +
    w1 + " 0, " +
    w1 + " " + length_to_head + ", " +
    w2 + " " + length_to_head + ", " +
    "0 " + length + ", " +
    -w2 + " " + length_to_head + ", " +
    -w1 + " " + length_to_head + ", " +
    -w1 + " 0, 0 0";
}

// return the degrees by which a link needs to be rotated counterclockwise from pointing straight down in order to
// point in the right direction
function getLinkRotationDegrees(l)
{
  var source = getNodeById(l.source);
  var dest = getNodeById(l.destination);
  var theta = Math.atan2((source.y - dest.y), (source.x - dest.x));
  return theta * 180 / Math.PI + 90;
}

// return a link icon's outline color
function getLinkIconOutlineColor(l)
{
  if(getNodeById(l.destination).identifiable)
  {
    return appearance.link_icon.outline_color_identifiable;
  }
  return appearance.link_icon.outline_color_unidentifiable;
}

// set up patterns to fill nodes, link icons, use icons, and other svg elements
function setUpPatterns()
{
  // create one identifiable and one unidentifiable version of each node and link icon
  {
    let num_node_types = node_types.length;
    for(let i = 0; i < num_node_types; i++)
    {
      if(node_types[i].all_data)
      {
        node_types.push({id: node_types[i].id + "_unidentifiable", image: node_types[i].image_unidentifiable, fill_color: appearance.node.fill_color_all_data});
        node_types[i].id = node_types[i].id + "_identifiable";
        node_types[i].image = node_types[i].image_identifiable;
        node_types[i].fill_color = appearance.node.fill_color_all_data;
      }
      else
      {
        node_types.push({id: node_types[i].id + "_unidentifiable", image: node_types[i].image, fill_color: appearance.node.fill_color_unidentifiable});
        node_types[i].id = node_types[i].id + "_identifiable";
        node_types[i].fill_color = appearance.node.fill_color_identifiable;
      }
    }

    let num_link_types = link_types.length;
    for(let i = 0; i < num_link_types; i++)
    {
      if(link_types[i].all_data)
      {
        link_types.push({id: link_types[i].id + "_unidentifiable", image: link_types[i].image, fill_color: appearance.node.fill_color_all_data});
        link_types[i].id = link_types[i].id + "_identifiable";
        link_types[i].fill_color = appearance.node.fill_color_all_data;
      }
      else
      {
        link_types.push({id: link_types[i].id + "_unidentifiable", image: link_types[i].image, fill_color: appearance.link_icon.fill_color_unidentifiable});
        link_types[i].id = link_types[i].id + "_identifiable";
        link_types[i].fill_color = appearance.link.fill_color_identifiable;
      }
    }
  }

  // node patterns
  node_patterns = svg_selection.select("#node_pattern_defs").selectAll("pattern")
    .data(node_types)
    .enter()
    .append("pattern")
      .attr("id", d => d.id)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  node_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.fill_color);
  node_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image);

  // link icon patterns
  link_icon_patterns = svg_selection.select("#link_pattern_defs").selectAll("pattern")
    .data(link_types)
    .enter()
    .append("pattern")
      .attr("id", d => d.id)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  link_icon_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", d => d.fill_color);
  link_icon_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image);

  // use icon patterns
  use_icon_patterns = svg_selection.select("#use_pattern_defs").selectAll("pattern")
    .data(use_types)
    .enter()
    .append("pattern")
      .attr("id", d => d.id)
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");
  use_icon_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", getUseTypeFillColor);
  use_icon_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", d => d.image);

  // other patterns
  other_patterns = svg_selection.select("#other_pattern_defs").append("pattern")
    .attr("id", "other_options")
    .attr("width", "1")
    .attr("height", "1")
    .attr("patternContentUnits", "objectBoundingBox");
  other_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", appearance.options_icon_on_node.fill_color);
  other_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", options_icon_image);
}

// create a stick with the child at the bottom and a specified number of parents preceding
function createStick(child, num_parents)
{
  if(num_parents <= 0)
    return child;
  else
    return createStick({ id: null, children: [child] }, num_parents - 1);
}

// recursively create a tree, given the root
function createTree(root)
{
  // make a copy of the root's successor links
  var successor_links = root.successor_links.slice();

  // if there are no successor links, then return the root as a leaf
  if(successor_links.length == 0)
  {
    return { id: root.id, children: [], siblings: [] };
  }
  // else if there are successor links, then return the root's branch
  else
  {
    var children = [];
    var siblings = [];

    // iterate through successor links
    for(var i = 0; i < successor_links.length; i++)
    {
      var s = getNodeById(successor_links[i].successor_id);
      var s_branch = createTree(s);

      // if the successor is in a higher layer than the root, then add it as a child
      if(s.layer > root.layer)
        children.push(createStick(s_branch, s.layer - root.layer - 1));
      // else if the successor is in the same layer as the root, then add it as a sibling
      else if(s.layer == root.layer)
        siblings.push(createTree(s));

      // add the successor's siblings as children of the root
      for(var j = 0; j < s_branch.siblings.length; j++)
      {
        children.push(createStick(s_branch.siblings[j], s.layer - root.layer - 1));
      }
    }

    // return a tree
    return { id: root.id, children: children, siblings: siblings };
  }
}

// update the node sidebar based on a node
function updateNodeSidebar(n)
{
  // set color of sidebar based on whether data is identifiable or not
  var fill_color;
  var outline_color;
  if(n.identifiable)
  {
    fill_color = appearance.node_sidebar.fill_color_identifiable;
    outline_color = appearance.node_sidebar.outline_color_identifiable;
  }
  else
  {
    fill_color = appearance.node_sidebar.fill_color_unidentifiable;
    outline_color = appearance.node_sidebar.outline_color_unidentifiable;
  }
  node_sidebar_selection
    .style("background-color", fill_color)
    .style("border-color", outline_color);


  // set basic sidebar text
  node_sidebar_selection.select("h1")
    .html(n.label);
  node_sidebar_selection.select("p")
    .html(n.text);

  // set information about options regarding the node
  if(n.options)
  {
    node_sidebar_options_container_selection.select("p")
      .html(n.options_text);

    node_sidebar_options_container_selection.style("display", "flex");
  }
  else
  {
    node_sidebar_options_container_selection.style("display", "none");
  }

  // if there are no uses to display, then hide the section
  if(n.layer == 0 || n.uses.length == 0)
  {
    node_sidebar_uses_container_selection
      .style("display", "none");
  }
  // if there are uses to display, then display them
  else
  {
    node_sidebar_uses_container_selection
      .style("display", "block");

    // update the heading
    node_sidebar_uses_container_selection.select("h2")
      .html(n.data_handler + " can use this data to...");

    // remove existing use divs
    node_sidebar_uses_container_selection.selectAll("div").remove();

    // add use divs to the sidebar
    var use_divs_selection = node_sidebar_uses_container_selection.selectAll("div")
      .data(n.uses)
      .enter().append("div")
        .classed("sidebar_list_item_container", true)
        .style("border-bottom", appearance.node_sidebar.outline_width + "px solid " + outline_color);

    // remove bottom border from last use div
    node_sidebar_uses_container_selection.select("div:last-child")
      .style("border-bottom", "none");

    // add icons and text to the use divs
    var icon_radius_with_outline = appearance.use_icon.radius + appearance.use_icon.outline_width;
    var use_divs_svgs_selection = use_divs_selection.append("svg")
      .attr("height", icon_radius_with_outline * 2 + "px")
      .style("flex-basis", d => getUseTypeById(d).all_data ? icon_radius_with_outline * 5 + "px"
                                                           : icon_radius_with_outline * 2 + "px");
    use_divs_svgs_selection.append("circle")
      .attr("r", appearance.use_icon.radius)
      .attr("cx", d => getUseTypeById(d).all_data ? 4 * icon_radius_with_outline : icon_radius_with_outline)
      .attr("cy", icon_radius_with_outline)
      .attr("fill", getUsePatternById)
      .attr("stroke", d => getUseTypeOutlineColor(getUseTypeById(d)))
      .attr("stroke-width", appearance.use_icon.outline_width);
    use_divs_svgs_selection.filter(d => getUseTypeById(d).all_data).append("polyline")
      .attr("transform", "translate(" + 0 + "," + icon_radius_with_outline + ") rotate(270)")
      .attr("points", getLinkPolylinePointsFromLength(getLinkPolylineLength(0, icon_radius_with_outline,
        4 * icon_radius_with_outline, icon_radius_with_outline,
        icon_radius_with_outline + appearance.link.arrowhead_to_node_distance)))
      .attr("fill", appearance.link.fill_color_background_highlight)
      .attr("stroke-width", 0);
    use_divs_selection.append("p")
      .html(function(d) { return getUseTypeById(d).description; });
  }

  // show the sidebar
  node_sidebar_container_selection
    .style("display", "inline-block");
}

// update the link sidebar based on a link
function updateLinkSidebar(l)
{
  var source = getNodeById(l.source);
  var dest = getNodeById(l.destination);

  // set color of sidebar based on whether data of destination node is identifiable or not
  var fill_color;
  var outline_color;
  if(dest.identifiable)
  {
    fill_color = appearance.link_sidebar.fill_color_identifiable;
    outline_color = appearance.link_sidebar.outline_color_identifiable;
  }
  else
  {
    fill_color = appearance.link_sidebar.fill_color_unidentifiable;
    outline_color = appearance.link_sidebar.outline_color_unidentifiable;
  }
  link_sidebar_selection
    .style("background-color", fill_color)
    .style("border-color", outline_color);

  var node_radius_with_outline = appearance.node.radius + appearance.node.outline_width;

  // update the link graphic
  link_sidebar_graphic_selection.select("polyline")
      .attr("points", getLinkPolylinePointsFromLength(getLinkPolylineLength(node_radius_with_outline,
        node_radius_with_outline, appearance.link_sidebar_graphic.distance_between_nodes + node_radius_with_outline,
        node_radius_with_outline, node_radius_with_outline + appearance.link.arrowhead_to_node_distance)))
      .attr("fill", getLinkFillColor(l));
  link_sidebar_graphic_selection.select("circle")
      .attr("fill", getNodePattern(source))
      .attr("stroke", getNodeOutlineColor(source));
  link_sidebar_graphic_selection.select("circle:nth-child(3)")
      .attr("fill", getNodePattern(dest))
      .attr("stroke", getNodeOutlineColor(dest));

  // set the icon and title for the link sidebar
  link_sidebar_selection.select("circle")
    .attr("fill", getLinkPattern(l))
    .attr("stroke", getLinkFillColor(l));
  link_sidebar_selection.select("h1")
    .html(getLinkTypeById(l.type + "_identifiable").label);
  link_sidebar_selection.select("p")
    .html(l.text);

  // show the sidebar
  link_sidebar_container_selection
    .style("display", "inline-block");
}

// update either the node or the link sidebar based on an input element
function updateSidebar(elt)
{
  if(elt.type == element_types.NODE)
  {
    updateNodeSidebar(elt.data);
  }
  else if(elt.type == element_types.LINK)
  {
    updateLinkSidebar(elt.data);
  }
}

// hide the sidebars
function hideSidebars()
{
  node_sidebar_container_selection
    .style("display", "none");
  link_sidebar_container_selection
    .style("display", "none");
}

// if the input element is a node, then gradually increase its radius to 1.3 times its normal value
function increaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection.select("circle")
      .transition()
      .attr("r", elt.data.radius * 1.3);
  }
}

// if the input element is a node, then gradually decrease its radius to its normal value
function decreaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection.select("circle")
      .transition()
      .attr("r", elt.data.radius);
  }
}

// change the input element's outline to indicate focus
function focusElementOutline(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection.select("circle")
      .attr("stroke", appearance.node.outline_color_focus)
      .attr("stroke-width", appearance.node.outline_width_focus);
  }
  else
  {
    elt.selection.select("polyline")
      .attr("stroke-width", appearance.link.outline_width_focus);
  }
}

// change the input element's outline to not indicate focus
function unfocusElementOutline(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection.select("circle")
      .attr("stroke", getNodeOutlineColor)
      .attr("stroke-width", appearance.node.outline_width);
  }
  else if(clicked_elt.type == element_types.LINK)
  {
    clicked_elt.selection.select("polyline")
      .attr("stroke-width", 0);
  }
}

// highlight a node's background arrow, if it has one
function highlightBackgroundArrow(elt)
{
  var a = background_links_selection.filter(d => d.source == elt.data.id);
  a.select("polyline")
    .attr("fill", appearance.link.fill_color_background_highlight);

  a.raise();
}

// unhighlight a node's background arrow, if it has one
function unhighlightBackgroundArrow(elt)
{
  background_links_selection.filter(d => d.source == elt.data.id).select("polyline")
    .attr("fill", appearance.link.fill_color_background);
}

// handle interactions when the cursor enters an interactive element
function onMouseEnter(elt)
{
  // display the correct sidebar
  hideSidebars();
  updateSidebar(elt);

  // if the cursor is over a node, then change its appearance
  if(elt.type == element_types.NODE)
  {
    increaseNodeRadius(elt);
    highlightBackgroundArrow(elt);
  }
}

// handle interactions when the cursor leaves an interactive element
function onMouseLeave(elt)
{
  // hide the sidebar
  hideSidebars();

  // if there is no clicked element, then if the cursor was over a node, then change its appearance back
  if(clicked_elt == null)
  {
    if(elt.type == element_types.NODE)
    {
      decreaseNodeRadius(elt);
      unhighlightBackgroundArrow(elt);
    }
  }
  // if there is a clicked element, then update the sidebar to display information about the clicked element
  else
  {
    updateSidebar(clicked_elt);

    // if the cursor was over a node, then unless the node is the clicked element, change its appearance back
    if(elt.data.id != clicked_elt.data.id)
    {
      if(elt.type == element_types.NODE)
      {
        decreaseNodeRadius(elt);
        unhighlightBackgroundArrow(elt);
      }
    }
  }
}

// handle interactions when the cursor clicks on an interactive element
function onClick(elt)
{
  // if there is no old clicked element, then focus on the new clicked element
  if(clicked_elt == null)
  {
    // change the outline of the new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if there is an old clicked element that is not the new clicked element, then focus away from the old and on the new
  else if(elt.data.id != clicked_elt.data.id)
  {
    // display the correct sidebar
    hideSidebars();
    updateSidebar(elt);

    // change the outline of the old clicked element back to normal, and change its appearance otherwise back
    unfocusElementOutline(clicked_elt);
    if(clicked_elt.type == element_types.NODE)
    {
      decreaseNodeRadius(clicked_elt);
      unhighlightBackgroundArrow(clicked_elt);
    }

    // change outline of new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if the new clicked element is the old clicked element, then focus away from it
  else
  {
    // change outline of clicked element back to normal
    unfocusElementOutline(elt);

    clicked_elt = null;
  }
}



function main()
{
  // set title and intro text
  d3.select("h1").html(title);
  d3.select("p").html(intro_text);

  // set up patterns for background fills
  setUpPatterns();

  // set display variables and elements
  {
    let display_radius = appearance.display.radius;

    let node_radius_with_outline = appearance.node.radius + appearance.node.outline_width;
    let link_icon_radius_with_outline = appearance.link_icon.radius + appearance.link_icon.outline_width;
    let options_icon_in_sidebar_radius_with_outline = appearance.options_icon_in_sidebar.radius +
      appearance.options_icon_in_sidebar.outline_width;

    let node_sidebar_extra_space = 2 * (appearance.node_sidebar.padding +
      appearance.node_sidebar.outline_width);
    let node_sidebar_max_height = 2 * display_radius - node_sidebar_extra_space;

    let link_sidebar_graphic_height = 2 * node_radius_with_outline;
    let link_sidebar_extra_space = 2 * (appearance.link_sidebar.padding +
      appearance.link_sidebar.outline_width);
    let link_sidebar_max_height = 2 * display_radius - link_sidebar_extra_space - link_sidebar_graphic_height -
      appearance.link_sidebar_graphic.margin_bottom;

    background_circles_radii = appearance.background_circle.radius_proportions.map(function(x) { return x * display_radius; });
    svg_selection
      .attr("width", 2 * display_radius)
      .attr("height", 2 * display_radius);
    g_selection.attr("transform", "translate(" + display_radius + "," + display_radius + ")");

    node_sidebar_selection
      .style("border", appearance.node_sidebar.outline_width + "px solid")
      .style("width", appearance.node_sidebar.width + "px")
      .style("max-height", node_sidebar_max_height + "px")
      .style("padding", appearance.node_sidebar.padding + "px");

    node_sidebar_options_container_selection.select("svg")
      .attr("width", 2 * options_icon_in_sidebar_radius_with_outline)
      .attr("height", 2 * options_icon_in_sidebar_radius_with_outline);
    node_sidebar_options_container_selection.select("h2")
      .html("You have some control over this data.");
    node_sidebar_options_container_selection.select("circle")
      .attr("cx", options_icon_in_sidebar_radius_with_outline)
      .attr("cy", options_icon_in_sidebar_radius_with_outline)
      .attr("r", appearance.options_icon_in_sidebar.radius)
      .attr("fill", "url(#other_options)")
      .attr("stroke", appearance.options_icon_in_sidebar.outline_color)
      .attr("stroke-width", appearance.options_icon_in_sidebar.outline_width);

    link_sidebar_selection
      .style("border", appearance.link_sidebar.outline_width + "px solid")
      .style("width", appearance.link_sidebar.width + "px")
      .style("max-height", link_sidebar_max_height + "px")
      .style("padding", appearance.link_sidebar.padding + "px");

    link_sidebar_graphic_selection
      .attr("width", (appearance.link_sidebar_graphic.distance_between_nodes + 2 * node_radius_with_outline) + "px")
      .attr("height", link_sidebar_graphic_height)
      .style("margin-bottom", appearance.link_sidebar_graphic.margin_bottom);
    link_sidebar_graphic_selection.select("polyline")
        .attr("transform", "translate(" + node_radius_with_outline + "," + node_radius_with_outline + ") rotate(270)")
        .attr("stroke-width", 0);
    link_sidebar_graphic_selection.select("circle")
        .attr("r", appearance.node.radius)
        .attr("cx", node_radius_with_outline)
        .attr("cy", node_radius_with_outline)
        .attr("stroke-width", appearance.node.outline_width);
    link_sidebar_graphic_selection.select("circle:nth-child(3)")
        .attr("r", appearance.node.radius)
        .attr("cx", appearance.link_sidebar_graphic.distance_between_nodes + node_radius_with_outline)
        .attr("cy", node_radius_with_outline)
        .attr("stroke-width", appearance.node.outline_width);

    link_sidebar_selection.select("svg")
      .attr("width", 2 * link_icon_radius_with_outline)
      .attr("height", 2 * link_icon_radius_with_outline)
      .select("circle")
        .attr("r", appearance.link_icon.radius)
        .attr("cx", link_icon_radius_with_outline)
        .attr("cy", link_icon_radius_with_outline)
        .attr("stroke-width", appearance.link_icon.outline_width);

    tree
      .size([(2 - appearance.layer_title.space_in_pi_radians) * Math.PI, display_radius])
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
  }



  // iterate through nodes to record special nodes, change node layers to essentially create a second sub-layer in
  // layer 1, and create links and background links
  for(let i = 0; i < nodes.length; i++)
  {
    let n = nodes[i];

    // if the node is the central node, record it, and add its successor links in layer 1 to the array of primary nodes
    if(n.layer == 0)
    {
      central_node = n;
      for(let j = 0; j < n.successor_links.length; j++)
      {
        let s = getNodeById(n.successor_links[j].successor_id);
        if(s.layer == 1)
        {
          primary_nodes.push(s);
        }
      }
    }

    // set the radius of the node
    n.radius = getNodeRadius(n);

    // fill links array with link objects based on the .json data
    for(let j = 0; j < n.successor_links.length; j++)
    {
      let l = n.successor_links[j];
      if(l.successor_id != base_all_data_node_id)
      {
        links.push({ id: n.id + "->" + l.successor_id, source: n.id, destination: l.successor_id, type: l.type, text: l.text });
      }
    }

    // if the node is in layer one and not an all_data node, add a background link to the base all_data node
    if(n.layer == 1 && ! n.all_data)
    {
      background_links.push({ id: n.id + "->" + base_all_data_node_id, source: n.id, destination: base_all_data_node_id, type: "link_all_data", text: "These lighter arrows point to a circle that tells you what " + primary_entity_name + " can do with all of your data." });
    }

    // move the node one node outward to accommodate for second sub-layer within layer 1 (center node and primary
    // nodes will later be moved back)
    n.layer += 1;
  }

  // move central node and primary nodes back to their original layer
  central_node.layer -= 1;
  primary_nodes.map(n => n.layer -= 1);



  // map nodes and create a d3 tree
  root = tree(d3.hierarchy(createTree(central_node)));
  tree_nodes = root.descendants();

  // set the coordinates of nodes to the coordinates of nodes in the tree, altered to make a radial tree
  for(let i = 0; i < nodes.length; i++)
  {
    let n = nodes[i];
    let offset = appearance.layer_title.space_in_pi_radians / 2 * Math.PI;
    matching_tree_node = tree_nodes.find(function(node) { return node.data.id == n.id; });
    n.x = (matching_tree_node.y = +matching_tree_node.y) * Math.cos((matching_tree_node.x -= Math.PI / 2) + offset);
    n.y = matching_tree_node.y * Math.sin(matching_tree_node.x + offset);

    // adjust the distance of nodes from the center, according to specified dimensions
    if(n.layer != 0)
    {
      n.x = n.x * appearance.node.distance_from_center_proportions[n.layer] / (n.layer / NUM_LAYERS);
      n.y = n.y * appearance.node.distance_from_center_proportions[n.layer] / (n.layer / NUM_LAYERS);
    }
  }



  // append background circles for layers
  for(let i = NUM_LAYERS - 1; i > 0; i--)
  {
    let r = background_circles_radii[i];

    g_selection.append("circle")
      .attr("r", r)
      .attr("fill", appearance.background_circle.fill_color)
      .attr("stroke", appearance.background_circle.outline_color)
      .attr("stroke-width", appearance.background_circle.outline_width);

    let r_for_text = r - appearance.layer_title.font_size - appearance.layer_title.distance_from_edge;
    let text;
    if(i == 2)
    {
      text = "Third parties";
    }
    else
    {
      text = primary_entity_name;
    }

    g_selection.append("path")
      .attr("id", "text_layer_" + i)
      .attr("d", "M-" + r_for_text + ",0 a" + r_for_text + "," + r_for_text + " 0 0 1 " + (2 * r_for_text) + ",0")
      .attr("fill", "none");
    g_selection.append("text")
      .classed("layer_title", true)
      .attr("text-anchor", "middle")
      .style("font-size", appearance.layer_title.font_size + "px")
      .style("fill", appearance.layer_title.color)
      .append("textPath")
        .html(text)
        .attr("xlink:href", "#text_layer_" + i)
        .attr("startOffset", "50%");
  }



  // append background links
  background_links_selection = g_selection.append("g").selectAll(".background_link")
    .data(background_links)
    .enter().append("g")
      .classed("background_link", true)
      .attr("transform", function(d)
      {
        let source = getNodeById(d.source);
        return "translate(" + source.x + "," + source.y + ")";
      });

  // add lines to background links
  background_links_selection.append("polyline")
    .attr("points", getLinkPolylinePoints)
    .attr("transform", function(d) { return "rotate(" + getLinkRotationDegrees(d) + ")"; })
    .attr("fill", appearance.link.fill_color_background)
    .attr("stroke", appearance.link.outline_color_focus)
    .attr("stroke-width", 0);

  // mouse interactions for background links
  background_links_selection
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.LINK, data:d, selection:d3.select(this)});
      d3.select(this).raise();
    })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.LINK, data:d, selection:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.LINK, data:d, selection:d3.select(this)}); });



  // append links
  links_selection = g_selection.append("g").selectAll(".link")
    .data(links)
    .enter().append("g")
      .classed("link", true)
      .attr("transform", function(d)
      {
        let source = getNodeById(d.source);
        return "translate(" + source.x + "," + source.y + ") rotate(" + getLinkRotationDegrees(d) + ")";
      });

  // add lines to links
  links_selection.append("polyline")
    .attr("points", getLinkPolylinePoints)
    .attr("fill", getLinkFillColor)
    .attr("stroke", appearance.link.outline_color_focus)
    .attr("stroke-width", 0);

  // add icons for special types of links
  links_selection.filter(d => getLinkTypeById(d.type + "_identifiable").display_on_link).append("circle")
    .attr("transform", function(d)
    {
      let source = getNodeById(d.source);
      let dest = getNodeById(d.destination);
      let length_to_head = getLinkPolylineLength(source.x, source.y, dest.x, dest.y,
        dest.radius + appearance.node.outline_width + appearance.link.arrowhead_to_node_distance)
        - appearance.link.arrowhead_length;
      let displacement = (length_to_head + source.radius) / 2;
      return "translate(0," + displacement + ") rotate(-" + getLinkRotationDegrees(d) + ")";
    })
    .attr("r", appearance.link_icon_on_link.radius)
    .attr("fill", getLinkPattern)
    .attr("stroke", getLinkFillColor)
    .attr("stroke-width", appearance.link_icon.outline_width);

  // mouse interactions for links
  links_selection
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.LINK, data:d, selection:d3.select(this)});
      d3.select(this).raise();
    })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.LINK, data:d, selection:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.LINK, data:d, selection:d3.select(this)}); });



  // append nodes
  nodes_selection = g_selection.append("g").selectAll(".node")
    .data(nodes)
    .enter().append("g")
      .classed("node", true)
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  // give the base all_data node an id
  nodes_selection.filter(d => d.id == base_all_data_node_id)
    .attr("id", base_all_data_node_id)

  // add circles to nodes
  nodes_selection.append("circle")
    .attr("r", getNodeRadius)
    .attr("fill", getNodePattern)
    .attr("stroke", getNodeOutlineColor)
    .attr("stroke-width", appearance.node.outline_width);

  // add options icon to nodes that contain options
  nodes_selection.filter(d => d.options == true).append("circle")
    .attr("cx", appearance.options_icon_on_node.cx)
    .attr("cy", appearance.options_icon_on_node.cy)
    .attr("r", appearance.options_icon_on_node.radius)
    .attr("fill", "url(#other_options)")
    .attr("stroke", appearance.options_icon_on_node.outline_color)
    .attr("stroke-width", appearance.options_icon_on_node.outline_width);

  // mouse interactions for nodes
  nodes_selection
    // display more information in the node sidebar when the cursor hovers over nodes
    .on("mouseenter", function(d)
    {
      onMouseEnter({type:element_types.NODE, data:d, selection:d3.select(this)});
      d3.select(this).raise();
    })
    // update the node sidebar when the cursor leaves a node
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.NODE, data:d, selection:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.NODE, data:d, selection:d3.select(this)}); });



  // mouse interactions for sidebar close buttons
  sidebar_close_buttons_selection
    .on("click", function(d)
    {
      let c = clicked_elt;
      onClick(c);
      onMouseLeave(c);
    })
}



// load data from .json files
d3.json("data/policies/strava.json").then(function(policy_json)
{
  d3.json("data/appearance.json").then(function(appearance_json)
  {
    // copy data from policy encoding .json file
    title = policy_json.title;
    intro_text = policy_json.intro_text;
    primary_entity_name = policy_json.primary_entity_name;
    base_all_data_node_id = policy_json.base_all_data_node_id;
    options_icon_image = policy_json.options_icon_image;
    nodes = policy_json.nodes;
    node_types = policy_json.node_types;
    link_types = policy_json.link_types;
    use_types = policy_json.use_types;

    // copy data from appearance .json file
    appearance = appearance_json;

    main();
  });
});

</script>

</body>
</html>
