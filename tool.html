<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8"/>
<title>D3 tool</title>
<link rel="stylesheet" type="text/css" href="styles.css">

</head>

<body>

<svg id="canvas">
  <defs></defs>
</svg>

<div id="node_info" class="hidden">
  <h1></h1>
  <p></p>
</div>

<script src="d3/d3.min.js"></script>
<script>

// arrays for nodes and links
var nodes_data;
var links_data = [];

// objects for colors, patterns, and dimensions
var colors_data;
var patterns_data;
var dimensions_data;
var layer_radii;

// variable for currently selected node
var clicked_node = null;

// svg to contain the main body of the graph
var svg = d3.select("#canvas");

// g to be placed at center of the graph
var g = svg.append("g");

// div sidebar to display additional information about nodes
var sidebar = d3.select("#node_info");

// node-mapping object to generate tree
var root;

// D3 tree to organize nodes
var tree = d3.tree();

// patterns to fill nodes
var patterns;

// links to connect nodes
var links;

// lines to display links
var links_lines;

// nodes to represent personal data
var nodes;

// circles to display nodes
var nodes_circles;



// return the node with a given id
function getNodeById(node_id)
{
  return nodes_data.find(function(node) { return node.id == node_id; });
}

// return the proper fill pattern of a node
function getNodeFillPattern(node)
{
  if(node.layer == 0)
  {
    return "url(#node_you)";
  }
  if(node.identifiable)
  {
    return "url(#node_identifiable)";
  }
  return "url(#node_unidentifiable)";
}

// return the outline color of a node
function getNodeOutlineColor(node)
{
  if(node.identifiable)
  {
    return colors_data.node_outline_identifiable;
  }
  return colors_data.node_outline_unidentifiable;
}

// return the radius of a node
function getNodeRadius(node)
{
  return dimensions_data.node_radii_by_layers[node.layer];
}

// return the color of a link
function getLinkColor(link)
{
  if(getNodeById(link.destination).identifiable)
  {
    return colors_data.link_identifiable;
  }
  return colors_data.link_unidentifiable;
}

// return the marker for the arrow of a link
function getLinkMarker(link)
{
  if(getNodeById(link.destination).identifiable)
  {
    return "url(#marker_identifiable)";
  }
  return "url(#marker_unidentifiable)";
}

// return the x-value of the end of a link (edge of the destination node, minus distance for the arrow head)
function getLinkX2(link)
{
  var source = getNodeById(link.source);
  var dest = getNodeById(link.destination);
  var theta = Math.atan((source.y - dest.y) / (source.x - dest.x));
  if(dest.x < source.x)
    return dest.x + ((dest.radius + dimensions_data.arrow_marker_length) * Math.cos(theta));
  else
    return dest.x - ((dest.radius + dimensions_data.arrow_marker_length) * Math.cos(theta));
}

// return the y-value of the end of a link (edge of the destination node, minus distance for the arrow head)
function getLinkY2(link)
{
  var source = getNodeById(link.source);
  var dest = getNodeById(link.destination);
  var theta = Math.atan((source.y - dest.y) / (source.x - dest.x));
  if(dest.x < source.x)
    return dest.y + ((dest.radius + dimensions_data.arrow_marker_length) * Math.sin(theta));
  else
    return dest.y - ((dest.radius + dimensions_data.arrow_marker_length) * Math.sin(theta));
}

// create a stick with the child at the bottom and a specified number of parents preceding
function createStick(child, num_parents)
{
  if(num_parents <= 0)
    return child;
  else
    return createStick({ id: null, children: [child] }, num_parents - 1);
}

// recursively create a tree, given the root
function createTree(root)
{
  // make a copy of the root's successors
  var successors = root.successors.slice();

  // if there are no successors, then return the root as a leaf
  if(successors.length == 0)
  {
    return { id: root.id, children: [], siblings: [] };
  }
  // else if there are successors, then return the root's branch
  else
  {
    var children = [];
    var siblings = [];

    // iterate through successors
    for(var i = 0; i < successors.length; i++)
    {
      var successor_node = getNodeById(successors[i]);
      var successor_branch = createTree(successor_node);

      // if the successor is in a higher layer than the root, then add it as a child
      if(successor_node.layer > root.layer)
        children.push(createStick(successor_branch, successor_node.layer - root.layer - 1));
      // else if the successor is in the same layer as the root, then add it as a sibling
      else if(successor_node.layer == root.layer)
        siblings.push(createTree(successor_node));

      // add the successor's siblings as children of the root
      for(var j = 0; j < successor_branch.siblings.length; j++)
      {
        children.push(createStick(successor_branch.siblings[j], successor_node.layer - root.layer - 1));
      }
    }

    // return a tree
    return { id: root.id, children: children, siblings: siblings };
  }
}

// update the sidebar based on a d3-selected node
function updateSidebar(node_selection)
{
  // set the sidebar text
  sidebar.select("h1")
    .text(node_selection.datum().label);
  sidebar.select("p")
    .text(node_selection.datum().text);

  // make the sidebar visible
  sidebar
    .classed("hidden", false);
  sidebar
    .classed("visible", true);
}

// hide the sidebar
function hideSidebar()
{
  // make the sidebar hidden
  sidebar
    .classed("visible", false);
  sidebar
    .classed("hidden", true);
}



function main()
{
  // set display variables
  layer_radii = [0, .4, .67, .95].map(function(x) { return x * dimensions_data.display_radius; });
  svg
    .attr("width", dimensions_data.display_radius * 2)
    .attr("height", dimensions_data.display_radius * 2);
  g
    .attr("transform", "translate(" + dimensions_data.display_radius + "," + dimensions_data.display_radius + ")");
  sidebar
    .style("border", dimensions_data.node_info_div_outline_width + "px solid " + colors_data.node_info_div_outline)
    .style("background-color", colors_data.node_info_div_fill)
    .style("width", dimensions_data.display_radius + "px")
    .style("height", (dimensions_data.display_radius - 10) * 2 + "px");
  tree
    .size([2 * Math.PI, dimensions_data.display_radius * .8])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });



  // map nodes and create a d3 tree
  root = tree(d3.hierarchy(createTree(nodes_data.find(function(node) { return node.layer == 0; }))));
  tree_nodes = root.descendants();

  // iterate through nodes to gather links and set node coordinates
  for(var i = 0; i < nodes_data.length; i++)
  {
    // fill links array with link objects based on the .json data
    var n = nodes_data[i];
    for(var j = 0; j < n.successors.length; j++)
    {
      links_data.push({ source: n.id, destination: n.successors[j] });
    }

    // set the coordinates of nodes based on the coordinates of nodes in the generated tree, altered to make a radial tree
    matching_tree_node = tree_nodes.find(function(node) { return node.data.id == n.id; });
    n.x = (matching_tree_node.y = +matching_tree_node.y) * Math.cos(matching_tree_node.x -= Math.PI / 2);
    n.y = matching_tree_node.y * Math.sin(matching_tree_node.x);

    // set the radius of nodes
    n.radius = getNodeRadius(n);
  }



  // append markers for arrows
  svg.select("defs").append("marker")
    .attr("id", "marker_identifiable")
    .attr("refX", 0)
    .attr("refY", dimensions_data.arrow_marker_width / 2)
    .attr("markerWidth", dimensions_data.arrow_marker_length)
    .attr("markerHeight", dimensions_data.arrow_marker_width)
    .attr("orient", "auto")
    .attr("markerUnits", "userSpaceOnUse")
    .append("path")
      .attr("d", "M 0 0 L " + dimensions_data.arrow_marker_length + " " + (dimensions_data.arrow_marker_width / 2) + " L 0 " + dimensions_data.arrow_marker_width + " Z")
      .attr("fill", colors_data.link_identifiable);

  svg.select("defs").append("marker")
    .attr("id", "marker_unidentifiable")
    .attr("refX", 0)
    .attr("refY", dimensions_data.arrow_marker_width / 2)
    .attr("markerWidth", dimensions_data.arrow_marker_length)
    .attr("markerHeight", dimensions_data.arrow_marker_width)
    .attr("orient", "auto")
    .attr("markerUnits", "userSpaceOnUse")
    .append("path")
      .attr("d", "M 0 0 L " + dimensions_data.arrow_marker_length + " " + (dimensions_data.arrow_marker_width / 2) + " L 0 " + dimensions_data.arrow_marker_width + " Z")
      .attr("fill", colors_data.link_unidentifiable);



  // append patterns - currently a pattern is an svg image on top of an svg circle (the circle is in case an image doesn't load), but this may be changed if we want to use a set of .svg icons instead of .png images
  patterns = svg.select("defs").selectAll("pattern")
    .data(patterns_data)
    .enter()
    .append("pattern")
      .attr("id", function(d) { return d.id; })
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");

  // add circles to patterns - radius is .49 so that it doesn't appear on the very edge of the image that goes on top
  patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".49")
    .attr("fill", function(d) { return d.background_color; });

  // add images to patterns
  patterns.append("image")
    .attr("x", "0")
    .attr("y", "0")
    .attr("width", "1")
    .attr("height", "1")
    .attr("xlink:href", function(d) { return d.image; });



  // append circles for layers
  for(var i = 3; i > 0; i--)
  {
    g.append("circle")
      .attr("r", layer_radii[i])
      .attr("fill", colors_data.layer_fill)
      .attr("stroke", colors_data.layer_outline)
      .attr("stroke-width", dimensions_data.layer_outline_width);
  }



  // append links
  links = g.selectAll(".link")
    .data(links_data)
    .enter()
    .append("g")
      .classed("link", true);

  // add lines to links
  links_lines = links.append("line")
    .attr("x1", function(d) { return getNodeById(d.source).x; })
    .attr("y1", function(d) { return getNodeById(d.source).y; })
    .attr("x2", getLinkX2)
    .attr("y2", getLinkY2)
    .attr("stroke", getLinkColor)
    .attr("stroke-width", dimensions_data.link_width)
    .attr("marker-end", getLinkMarker);

  // mouse interactions for links
  links_lines
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d)
    {
      g.append("text")
        .attr("id", "hover_message")
        .attr("x", function() { return (getNodeById(d.source).x + getNodeById(d.destination).x) / 2; })
        .attr("y", function() { return (getNodeById(d.source).y + getNodeById(d.destination).y) / 2; })
        .text("hello");
    })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d)
    {
      d3.select("#hover_message").remove();
    });



  // append nodes
  nodes = g.selectAll(".node")
    .data(nodes_data)
    .enter().append("g")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
      .attr("id", function(d) { return d.id; });

  // add circles to nodes
  nodes_circles = nodes.append("circle")
    .attr("r", getNodeRadius)
    .attr("fill", getNodeFillPattern)
    .attr("stroke", getNodeOutlineColor)
    .attr("stroke-width", dimensions_data.node_outline_width)
    .attr("id", function(d) { return d3.select(this.parentElement).attr("id") + "_circle"; });

  // mouse interactions for nodes
  nodes_circles
    // display more information in the sidebar when the cursor hovers over nodes
    .on("mouseenter", function(d)
    {
      var node_selection = d3.select(this);

      updateSidebar(node_selection);

      // increase the size of the node that the cursor is over
      node_selection
        .transition()
        .attr("r", d.radius * 1.3);
    })
    // update the sidebar when the cursor leaves a node
    .on("mouseleave", function(d)
    {
      var node_selection = d3.select(this);

      // if there is no clicked node, then hide the sidebar
      if(clicked_node == null)
      {
        hideSidebar();

        // decrease the size of the node that the cursor was over, back to normal
        node_selection
          .transition()
          .attr("r", d.radius);
      }
      // if there is a clicked node, then update the sidebar to display information about the clicked node
      else
      {
        updateSidebar(clicked_node);

        // unless the node that the cursor was over was the clicked node, ddecrease its size back to normal
        if(clicked_node.attr("id") != node_selection.attr("id"))
        {
          // make the node that the cursor was over shrink back
          node_selection
            .transition()
            .attr("r", d.radius);
        }
      }
    })
    // retain focus on a node when it is clicked
    .on("click", function(d)
    {
      var new_clicked_node = d3.select(this);

      // if there is no old clicked node, then focus on the new clicked node
      if(clicked_node == null)
      {
        // change outline of new clicked node to indicate focus
        new_clicked_node
          .attr("stroke", colors_data.node_outline_click_focus)
          .attr("stroke-width", dimensions_data.node_outline_click_focus_width);

        clicked_node = new_clicked_node;
      }
      // if there is an old clicked node that is not the new clicked node, then focus away from the old and on the new
      else if(clicked_node.attr("id") != new_clicked_node.attr("id"))
      {
        updateSidebar(new_clicked_node);

        // change outline of old clicked node back to normal, and decrease size back to normal
        clicked_node
          .attr("stroke", getNodeOutlineColor)
          .attr("stroke-width", dimensions_data.node_outline_width)
          .transition()
          .attr("r", clicked_node.datum().radius);

        // change outline of new clicked node to indicate focus
        new_clicked_node
          .attr("stroke", colors_data.node_outline_click_focus)
          .attr("stroke-width", dimensions_data.node_outline_click_focus_width);

        clicked_node = new_clicked_node;
      }
      // if the new clicked node is the old clicked node, then focus away from it
      else
      {
        // change outline of clicked node back to normal
        clicked_node
          .attr("stroke", getNodeOutlineColor)
          .attr("stroke-width", dimensions_data.node_outline_width);

        clicked_node = null;
      }
    });
}



// load data from .json file
d3.json("data/policy_encoding.json").then(function(policy_encoding_data)
{
  d3.json("data/appearance.json").then(function(appearance_data)
  {
    // copy data from policy encoding .json file
    nodes_data = policy_encoding_data;

    // copy data from appearance .json file
    colors_data = appearance_data.colors;
    patterns_data = appearance_data.patterns;
    dimensions_data = appearance_data.dimensions;

    main();
  });
});

</script>

</body>
</html>
