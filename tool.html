<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8"/>
<title>D3 tool</title>
<link rel="stylesheet" type="text/css" href="styles.css">

</head>

<body>

<svg id="canvas">
  <defs></defs>
</svg>

<div id="node_info" class="hidden">
  <h1></h1>
  <p></p>
</div>

<script src="d3/d3.min.js"></script>
<script>

// arrays for nodes and links
var nodes_data;
var links_data;

// node-mapping object for generating tree
var root;

// initialize display dimensions
const display_radius = 300;
const center_x = display_radius;
const center_y = display_radius;

// initialize layers array containing important information on the layer level
var layers =
[
  { radius: 0,                    nodes: [], svg_nodes: [], svg_circles: [], svg_imgs: [], svg_background: undefined },
  { radius: display_radius * .4,  nodes: [], svg_nodes: [], svg_circles: [], svg_imgs: [], svg_background: undefined },
  { radius: display_radius * .67, nodes: [], svg_nodes: [], svg_circles: [], svg_imgs: [], svg_background: undefined },
  { radius: display_radius * .95, nodes: [], svg_nodes: [], svg_circles: [], svg_imgs: [], svg_background: undefined }
];

// objects for colors, patterns, and widths
var colors;
var patterns;
var widths;
var node_radii;

// return the node with a given id from a list of nodes
// this is a bit inefficient, as it requires passing a copy of the array nodes as an argument (if I understand JavaScript correctly)
function getNodeById(node_id)
{
  return nodes_data.find(function(node) { return node.id == node_id; });
}

// return the proper fill color of a node
function getNodeFillPattern(node)
{
  if(node.layer == 0)
  {
    return "url(#node_you)";
  }
  if(node.identifiable == 1)
  {
    return "url(#node_identifiable)";
  }
  return "url(#node_unidentifiable)";
}

// return the outline color of a node
function getNodeOutlineColor(node)
{
  if(node.identifiable == 1)
  {
    return colors.nodes_outline_identifiable;
  }
  return colors.nodes_outline_unidentifiable;
}

// return the color of a link
function getLinkColor(link)
{
  if(getNodeById(link.destination).identifiable == 1)
  {
    return colors.links_identifiable;
  }
  return colors.links_unidentifiable;
}

// return the radius of a node
function getNodeRadius(node)
{
  return node_radii.layers[node.layer];
}

// create variable for svg and set size
var svg = d3.select("#canvas")
  .attr("width", display_radius * 2)
  .attr("height", display_radius * 2);

// add a g in the middle of the svg
var g = svg.append("g")
  .attr("transform", "translate(" + display_radius + "," + display_radius + ")");

var node_info_div = d3.select("#node_info");

// load data from .json file
d3.json("data/data.json").then(function(data)
{
  // initialize nodes and links arrays
  nodes_data = data.nodes;
  links_data = [];

  // initialize colors, patterns, and widths objects
  colors = data.colors;
  patterns = data.patterns;
  widths = data.widths;
  node_radii = data.node_radii;

  // set properties for node info div
  node_info_div
    .style("border", widths.node_info_div_outline + "px solid " + colors.node_info_div_outline)
    .style("background-color", colors.node_info_div_fill)
    .style("width", display_radius + "px")
    .style("height", (display_radius - 10) * 2 + "px");

  // create variable for tree and set basic properties
  var tree = d3.tree()
    .size([2 * Math.PI, display_radius * .8])
    .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });

  // functions fills in root and children for tree
  function makeRoot(root)
  {
    if(root.edges_out.length == 0)
    {
      return { id: root.id };
    }
    else
    {
      return { id: root.id, children: root.edges_out.map(function(child_id) { return makeRoot(getNodeById(child_id)); }) };
    }
  }

  // map nodes and create a d3 tree
  root = tree(d3.hierarchy(makeRoot(nodes_data[0])));//currently assumes first node is center, but we should fix this later
  tree_nodes = root.descendants();

  // iterate through nodes to gather links and set node coordinates
  for(var i = 0; i < nodes_data.length; i++)
  {
    // fill links array with link objects based on the .json data
    var current_node = nodes_data[i];
    for(var j = 0; j < current_node.edges_out.length; j++)
    {
      links_data.push({ source: current_node.id, destination: current_node.edges_out[j] });
    }

    // set the coordinates of nodes based on the coordinates of nodes in the generated tree, altered to make a radial tree
    matching_tree_node = tree_nodes.find(function(node) { return node.data.id == current_node.id; });
    current_node.x = (matching_tree_node.y = +matching_tree_node.y) * Math.cos(matching_tree_node.x -= Math.PI / 2);
    current_node.y = matching_tree_node.y * Math.sin(matching_tree_node.x);

    // set the radius of nodes
    current_node.radius = getNodeRadius(current_node);
  }

  // add patterns for node fills - currently a pattern is an svg image on top of an svg circle (the circle is in case an image doesn't load), but this may be changed if we want to use a set of .svg icons instead of .png images
  var patterns = svg.select("defs").selectAll("pattern")
    .data(patterns)
    .enter()
    .append("pattern")
      .attr("id", function(pattern) { return pattern.id })
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");

  // add circles to patterns - radius is .49 so that it doesn't appear on the very edge of the image that goes on top
  patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".49")
    .attr("fill", function(pattern) { return pattern.background_color });

  // add images to patterns
  patterns.append("image")
    .attr("x", "0")
    .attr("y", "0")
    .attr("width", "1")
    .attr("height", "1")
    .attr("xlink:href", function(pattern) { return pattern.image });

  // append circles for layers
  for(var i = 3; i > 0; i--)
  {
    layers[i].svg_background = g.append("circle")
      .attr("r", layers[i].radius)
      .attr("fill", colors.layers_fill)
      .attr("stroke", colors.layers_outline)
      .attr("stroke-width", widths.layers_outline);
  }

  // append links
  var links = g.selectAll(".link")
    .data(links_data)
    .enter()
    .append("g")
      .classed("link", true);

  // add lines to links
  var links_lines = links.append("line")
    .attr("x1", function(link) { return getNodeById(link.source).x })
    .attr("y1", function(link) { return getNodeById(link.source).y })
    .attr("x2", function(link) { return getNodeById(link.destination).x })
    .attr("y2", function(link) { return getNodeById(link.destination).y })
    .attr("stroke", getLinkColor)
    .attr("stroke-width", widths.links);

  // display more information when the cursor hovers over links
  links_lines
    .on("mouseenter", function(link)
    {
      g.append("text")
        .attr("id", "hover_message")
        .attr("x", function() { return (getNodeById(link.source).x + getNodeById(link.destination).x) / 2 })
        .attr("y", function() { return (getNodeById(link.source).y + getNodeById(link.destination).y) / 2 })
        .text("hello");
    })
    .on("mouseleave", function(link)
    {
      d3.select("#hover_message").remove();
    });

  // append nodes
  var nodes = g.selectAll(".node")
    .data(nodes_data)
    .enter().append("g")
      .attr("transform", function(node) { return "translate(" + node.x + "," + node.y + ")" });

  // add circles to nodes
  var nodes_circles = nodes.append("circle")
    .attr("r", getNodeRadius)
    .attr("fill", getNodeFillPattern)
    .attr("stroke", getNodeOutlineColor)
    .attr("stroke-width", widths.nodes_outline);

  // display more information when the cursor hovers over nodes
  nodes_circles
    .on("mouseenter", function(node)
    {
      node_info_div.select("h1")
        .text(node.label);
      node_info_div.select("p")
        .text(node.text);
      node_info_div
        .classed("hidden", false);
      node_info_div
        .classed("visible", true);
      d3.select(this)
        .transition()
        .attr("r", node.radius * 1.5);
    })
    .on("mouseleave", function(node)
    {
      node_info_div
        .classed("visible", false);
      node_info_div
        .classed("hidden", true);
      d3.select(this)
        .transition()
        .attr("r", node.radius);
    });
});

</script>

</body>
</html>
