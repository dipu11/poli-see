<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8"/>
<title>Privacy Poli-see</title>
<link rel="stylesheet" type="text/css" href="styles.css">
<link rel="icon" type="image/png" href="images/icon32.png">

</head>

<body>

<h1></h1>
<p></p>

<div class="tool_container">
  <svg id="canvas">
    <defs id="node_pattern_defs"></defs>
    <defs id="link_pattern_defs"></defs>
    <defs id="use_pattern_defs"></defs>
  </svg>

  <div id="node_sidebar_container" class="sidebar_container" style="display: none">
    <div id="node_sidebar" class="sidebar">
      <h1></h1>
      <p></p>
      <h2></h2>
    </div>
  </div>

  <div id="link_sidebar_container" class="sidebar_container" style="display: none">
    <svg id="link_sidebar_summary">
      <polyline></polyline>
      <circle></circle>
      <circle></circle>
    </svg>
    <div id="link_sidebar" class="sidebar">
      <svg>
        <circle></circle>
      </svg>
      <p></p>
    </div>
  </div>
</div>

<script src="d3/d3.min.js"></script>
<script>

// enumerated constants for types of elements
const element_types =
{
  NODE: "node",
  LINK: "link"
}

// variables for title and intro text
var title;
var intro_text;

// arrays for nodes and links
var nodes_data;
var links_data = [];

// arrays for node, link, and use types
var node_types_data;
var link_types_data;
var use_types_data;

// objects for colors and dimensions
var colors_data;
var dimensions_data;
var layer_outline_radii;

// variable for currently selected element
var clicked_elt = null;

// svg to contain the main body of the graph
var svg = d3.select("#canvas");
// g to be placed at center of the graph
var g = svg.append("g");

// div containers to contain sidebars and potentially other display elements accompanying sidebars
var node_sidebar_container = d3.select("#node_sidebar_container");
var link_sidebar_container = d3.select("#link_sidebar_container");

// div sidebars to display additional information about nodes and links
var node_sidebar = d3.select("#node_sidebar");
var link_sidebar = d3.select("#link_sidebar");

// svg for link sidebar summary
var link_sidebar_summary = d3.select("#link_sidebar_summary");

// node-mapping object to generate tree
var root;

// D3 tree to organize nodes
var tree = d3.tree();

// node, link icon, and use icon fill patterns
var node_patterns;
var link_patterns;
var use_patterns;

// links to connect nodes
var links;
// polylines to display links
var links_polylines;

// nodes to represent personal data
var nodes;
// circles to display nodes
var nodes_circles;



// return the node with a given id
function getNodeById(node_id)
{
  return nodes_data.find(function(node) { return node.id == node_id; });
}

// return the node type with a given id
function getNodeTypeById(node_type_id)
{
  return node_types_data.find(function(node_type) { return node_type.id == node_type_id; });
}

// return the link type with a given id
function getLinkTypeById(link_type_id)
{
  return link_types_data.find(function(link_type) { return link_type.id == link_type_id; });
}

// return the use type with a given id
function getUseTypeById(use_type_id)
{
  return use_types_data.find(function(use_type) { return use_type.id == use_type_id; });
}

// return the proper fill pattern of a node
function getNodePattern(node)
{
  var url = "#" + node.type;

  if(node.identifiable)
    url += "_identifiable";
  else
    url += "_unidentifiable";

  return "url(" + url + ")";
}

// return the proper icon fill pattern of a link
function getLinkPattern(link)
{
  var url = "#" + link.type;

  return "url(" + url + ")";
}

// return the proper icon fill pattern of a use, given its id
function getUsePatternById(use_id)
{
  var url = "#" + use_id;

  return "url(" + url + ")";
}

// return the outline color of a node
function getNodeOutlineColor(node)
{
  if(node.identifiable)
  {
    return colors_data.node_outline_identifiable;
  }
  return colors_data.node_outline_unidentifiable;
}

// return the radius of a node
function getNodeRadius(node)
{
  if(node.layer == 0)
  {
    return dimensions_data.center_node_radius;
  }
  return dimensions_data.node_radius;
}

// return the fill color of a link
function getLinkFillColor(link)
{
  if(getNodeById(link.destination).identifiable)
  {
    return colors_data.link_fill_identifiable;
  }
  return colors_data.link_fill_unidentifiable;
}

// return the outline color of a link
function getLinkOutlineColor(link)
{
  if(getNodeById(link.destination).identifiable)
  {
    return colors_data.link_outline_identifiable;
  }
  return colors_data.link_outline_unidentifiable;
}

// return a string containing the points for a link polyline arrow pointing down, given a link's data
function createLinkPolylineFromLink(link)
{
  var source = getNodeById(link.source);
  var dest = getNodeById(link.destination);
  return createLinkPolylineFromValues(source.x, source.y, dest.x, dest.y,
    dest.radius + dimensions_data.node_outline_width + 3);
}

// return a string containing the points for a link polyline arrow pointing down, given necessary values
function createLinkPolylineFromValues(source_x, source_y, dest_x, dest_y, subtract_len)
{
  var length = Math.sqrt( Math.pow((dest_x - source_x), 2) + Math.pow((dest_y - source_y), 2)) - subtract_len;
  var length_to_head = length - dimensions_data.link_arrowhead_length;
  var w1 = dimensions_data.link_width / 2;
  var w2 = dimensions_data.link_arrowhead_width / 2;
  return "0 0, " +
    w1 + " 0, " +
    w1 + " " + length_to_head + ", " +
    w2 + " " + length_to_head + ", " +
    "0 " + length + ", " +
    -w2 + " " + length_to_head + ", " +
    -w1 + " " + length_to_head + ", " +
    -w1 + " 0, 0 0";
}

// return the degrees by which a link needs to be rotated counterclockwise from pointing straight down in order to
// point in the right direction
function getLinkRotationDegrees(link)
{
  var source = getNodeById(link.source);
  var dest = getNodeById(link.destination);
  var theta = Math.atan2((source.y - dest.y), (source.x - dest.x));
  return theta * 180 / Math.PI + 90;
}

// create a stick with the child at the bottom and a specified number of parents preceding
function createStick(child, num_parents)
{
  if(num_parents <= 0)
    return child;
  else
    return createStick({ id: null, children: [child] }, num_parents - 1);
}

// recursively create a tree, given the root
function createTree(root)
{
  // make a copy of the root's successors
  var successors = root.successors.slice();

  // if there are no successors, then return the root as a leaf
  if(successors.length == 0)
  {
    return { id: root.id, children: [], siblings: [] };
  }
  // else if there are successors, then return the root's branch
  else
  {
    var children = [];
    var siblings = [];

    // iterate through successors
    for(var i = 0; i < successors.length; i++)
    {
      var successor_node = getNodeById(successors[i].id);
      var successor_branch = createTree(successor_node);

      // if the successor is in a higher layer than the root, then add it as a child
      if(successor_node.layer > root.layer)
        children.push(createStick(successor_branch, successor_node.layer - root.layer - 1));
      // else if the successor is in the same layer as the root, then add it as a sibling
      else if(successor_node.layer == root.layer)
        siblings.push(createTree(successor_node));

      // add the successor's siblings as children of the root
      for(var j = 0; j < successor_branch.siblings.length; j++)
      {
        children.push(createStick(successor_branch.siblings[j], successor_node.layer - root.layer - 1));
      }
    }

    // return a tree
    return { id: root.id, children: children, siblings: siblings };
  }
}

// update the node sidebar based on a node's data
function updateNodeSidebar(n_data)
{
  // set the sidebar text
  node_sidebar.select("h1")
    .html(n_data.label);
  node_sidebar.select("p")
    .html(n_data.text);
  if(n_data.layer == 0)
  {
    node_sidebar.select("h2")
      .html("");
  }
  else
  {
    node_sidebar.select("h2")
      .html(n_data.data_handler + " can use this data to...");
  }

  // add use divs to the sidebar
  node_sidebar.selectAll("div").remove();
  var use_divs = node_sidebar.selectAll("div")
    .data(n_data.uses)
    .enter().append("div")
      .style("border-bottom", dimensions_data.node_sidebar_outline_width + "px solid " + colors_data.node_sidebar_outline);

  // add icons and text to the use divs
  var icon_radius_with_outline = dimensions_data.use_icon_radius + dimensions_data.use_icon_outline_width;
  var use_svgs = use_divs.append("svg")
    .attr("width", icon_radius_with_outline * 2)
    .attr("height", icon_radius_with_outline * 2);
  use_svgs.append("circle")
    .attr("r", dimensions_data.use_icon_radius)
    .attr("cx", icon_radius_with_outline)
    .attr("cy", icon_radius_with_outline)
    .attr("fill", getUsePatternById)
    .attr("stroke", colors_data.use_icon_outine)
    .attr("stroke-width", dimensions_data.use_icon_outline_width);
  use_divs.append("span")
    .html(function(d) { return getUseTypeById(d).label; });

  // show the sidebar
  node_sidebar_container
    .style("display", "inline-block");
}

// update the link sidebar based on a link's data
function updateLinkSidebar(l_data)
{
  var source_data = getNodeById(l_data.source);
  var dest_data = getNodeById(l_data.destination);

  var node_radius_with_outline = dimensions_data.node_radius + dimensions_data.node_outline_width;

  // update the link summary
  link_sidebar_summary.select("polyline")
      .attr("points", createLinkPolylineFromValues(node_radius_with_outline, node_radius_with_outline,
        dimensions_data.display_radius - node_radius_with_outline, node_radius_with_outline,
        dimensions_data.link_icon_radius + dimensions_data.link_icon_outline_width + 3))
      .attr("fill", getLinkFillColor(l_data))
      .attr("stroke", getLinkOutlineColor(l_data));
  link_sidebar_summary.select("circle")
      .attr("fill", getNodePattern(source_data))
      .attr("stroke", getNodeOutlineColor(source_data));
  link_sidebar_summary.select("circle:nth-child(3)")
      .attr("fill", getNodePattern(dest_data))
      .attr("stroke", getNodeOutlineColor(dest_data));

  // set the icon for the link sidebar
  link_sidebar.select("circle")
    .attr("fill", getLinkPattern(l_data));

  // set the sidebar text
  link_sidebar.select("p")
    .html(l_data.text);

  // show the sidebar
  link_sidebar_container
    .style("display", "inline-block");
}

// update either the node or the link sidebar based on an input element
function updateSidebar(elt)
{
  if(elt.type == element_types.NODE)
  {
    updateNodeSidebar(elt.data);
  }
  else if(elt.type == element_types.LINK)
  {
    updateLinkSidebar(elt.data);
  }
}

// hide the sidebars
function hideSidebars()
{
  node_sidebar_container
    .style("display", "none");
  link_sidebar_container
    .style("display", "none");
}

// if the input element is a node, then gradually increase its radius to 1.3 times its normal value
function increaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection
      .transition()
      .attr("r", elt.data.radius * 1.3);
  }
}

// if the input element is a node, then gradually decrease its radius to its normal value
function decreaseNodeRadius(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection
      .transition()
      .attr("r", elt.data.radius);
  }
}

// change the input element's outline to indicate focus
function focusElementOutline(elt)
{
  elt.selection
    .attr("stroke", colors_data.click_focus_outline)
    .attr("stroke-width", dimensions_data.click_focus_outline_width);
}

// change the input element's outline to not indicate focus
function unfocusElementOutline(elt)
{
  if(elt.type == element_types.NODE)
  {
    elt.selection
      .attr("stroke", getNodeOutlineColor)
      .attr("stroke-width", dimensions_data.node_outline_width);
  }
  else if(clicked_elt.type == element_types.LINK)
  {
    clicked_elt.selection
      .attr("stroke", getLinkOutlineColor)
      .attr("stroke-width", dimensions_data.link_outline_width);
  }
}

// handle interactions when the cursor enters an interactive element
function onMouseEnter(elt)
{
  // display the correct sidebar
  hideSidebars();
  updateSidebar(elt);

  // if the cursor is over a node, then increase the node's size
  increaseNodeRadius(elt);
}

// handle interactions when the cursor leaves an interactive element
function onMouseLeave(elt)
{
  // hide the sidebar
  hideSidebars();

  // if there is no clicked element, then if the cursor was over a node, just decrease the node's size back to normal
  if(clicked_elt == null)
  {
    decreaseNodeRadius(elt);
  }
  // if there is a clicked element, then update the sidebar to display information about the clicked element
  else
  {
    updateSidebar(clicked_elt);

    // if the cursor was over a node, then unless the node is the clicked element, decrease its size back to normal
    if(elt.data.id != clicked_elt.data.id)
    {
      decreaseNodeRadius(elt);
    }
  }
}

// handle interactions when the cursor clicks on an interactive element
function onClick(elt)
{
  // if there is no old clicked element, then focus on the new clicked element
  if(clicked_elt == null)
  {
    // change the outline of the new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if there is an old clicked element that is not the new clicked element, then focus away from the old and on the new
  else if(elt.data.id != clicked_elt.data.id)
  {
    // display the correct sidebar
    hideSidebars();
    updateSidebar(elt);

    // change the outline of the old clicked element back to normal, and decrease its size back to normal if it was a node
    unfocusElementOutline(clicked_elt);
    decreaseNodeRadius(clicked_elt);

    // change outline of new clicked element to indicate focus
    focusElementOutline(elt);

    clicked_elt = elt;
  }
  // if the new clicked element is the old clicked element, then focus away from it
  else
  {
    // change outline of clicked element back to normal
    unfocusElementOutline(elt);

    clicked_elt = null;
  }
}



function main()
{
  // set title and intro text
  d3.select("h1").html(title);
  d3.select("p").html(intro_text);

  // set display variables and elements
  {
    let display_radius = dimensions_data.display_radius;

    let node_sidebar_extra_space = 2 * (dimensions_data.node_sidebar_padding +
      dimensions_data.node_sidebar_outline_width);
    let node_sidebar_width = display_radius - node_sidebar_extra_space;
    let node_sidebar_height = 2 * display_radius - node_sidebar_extra_space;

    let link_sidebar_summary_height = 2 * (dimensions_data.node_radius + dimensions_data.node_outline_width);
    let link_sidebar_extra_space = 2 * (dimensions_data.link_sidebar_padding +
      dimensions_data.link_sidebar_outline_width);
    let link_sidebar_width = display_radius - link_sidebar_extra_space;
    let link_sidebar_height = 2 * display_radius - link_sidebar_extra_space - link_sidebar_summary_height;

    let node_radius_with_outline = dimensions_data.node_radius + dimensions_data.node_outline_width;
    let link_icon_radius_with_outline = dimensions_data.link_icon_radius + dimensions_data.link_icon_outline_width;

    layer_outline_radii = dimensions_data.layer_outline_radii_proportions.map(function(x) { return x * display_radius; });
    svg
      .attr("width", 2 * display_radius)
      .attr("height", 2 * display_radius);
    g.attr("transform", "translate(" + display_radius + "," + display_radius + ")");

    node_sidebar
      .style("border", dimensions_data.node_sidebar_outline_width + "px solid " + colors_data.node_sidebar_outline)
      .style("background-color", colors_data.node_sidebar_fill)
      .style("width", node_sidebar_width + "px")
      .style("height", node_sidebar_height + "px")
      .style("padding", dimensions_data.node_sidebar_padding + "px");

    link_sidebar
      .style("border", dimensions_data.link_sidebar_outline_width + "px solid " + colors_data.link_sidebar_outline)
      .style("background-color", colors_data.link_sidebar_fill)
      .style("width", link_sidebar_width + "px")
      .style("height", link_sidebar_height + "px")
      .style("padding", dimensions_data.link_sidebar_padding + "px");

    link_sidebar_summary
      .attr("width", display_radius + "px")
      .attr("height", link_sidebar_summary_height);
    link_sidebar_summary.select("polyline")
        .attr("transform", "translate(" + node_radius_with_outline + "," + node_radius_with_outline + ") rotate(270)")
        .attr("stroke-width", dimensions_data.link_outline_width);
    link_sidebar_summary.select("circle")
        .attr("r", dimensions_data.node_radius)
        .attr("cx", node_radius_with_outline)
        .attr("cy", node_radius_with_outline)
        .attr("stroke-width", dimensions_data.node_outline_width);
    link_sidebar_summary.select("circle:nth-child(3)")
        .attr("r", dimensions_data.node_radius)
        .attr("cx", dimensions_data.display_radius - node_radius_with_outline)
        .attr("cy", node_radius_with_outline)
        .attr("stroke-width", dimensions_data.node_outline_width);

    link_sidebar.select("svg")
      .attr("width", link_icon_radius_with_outline * 2)
      .attr("height", link_icon_radius_with_outline * 2)
      .select("circle")
        .attr("r", dimensions_data.link_icon_radius)
        .attr("cx", link_icon_radius_with_outline)
        .attr("cy", link_icon_radius_with_outline)
        .attr("stroke", colors_data.link_icon_outine)
        .attr("stroke-width", dimensions_data.link_icon_outline_width);

    tree
      .size([2 * Math.PI, display_radius])
      .separation(function(a, b) { return (a.parent == b.parent ? 1 : 2) / a.depth; });
  }


  // create one identifiable and one unidentifiable version of each node icon
  {
    let num_node_types = node_types_data.length;
    for(let i = 0; i < num_node_types; i++)
    {
      node_types_data.push({id: node_types_data[i].id + "_unidentifiable", image: node_types_data[i].image, fill_color: colors_data.node_fill_unidentifiable});
      node_types_data[i].id = node_types_data[i].id + "_identifiable";
      node_types_data[i].fill_color = colors_data.node_fill_identifiable;
    }
  }



  // map nodes and create a d3 tree
  root = tree(d3.hierarchy(createTree(nodes_data.find(function(node) { return node.layer == 0; }))));
  tree_nodes = root.descendants();

  // iterate through nodes to gather links and set node coordinates
  for(let i = 0; i < nodes_data.length; i++)
  {
    // fill links array with link objects based on the .json data
    let n = nodes_data[i];
    for(let j = 0; j < n.successors.length; j++)
    {
      let s = n.successors[j];
      links_data.push({ id: n.id + "->" + s.id, source: n.id, destination: s.id, type: s.type, text: s.text });
    }

    // set the coordinates of nodes to the coordinates of nodes in the tree, altered to make a radial tree
    matching_tree_node = tree_nodes.find(function(node) { return node.data.id == n.id; });
    n.x = (matching_tree_node.y = +matching_tree_node.y) * Math.cos(matching_tree_node.x -= Math.PI / 2);
    n.y = matching_tree_node.y * Math.sin(matching_tree_node.x);

    if(n.layer != 0)
    {
      n.x = n.x * dimensions_data.layer_radii_proportions[n.layer] / (n.layer / 3);
      n.y = n.y * dimensions_data.layer_radii_proportions[n.layer] / (n.layer / 3);
    }
    // set the radius of nodes
    n.radius = getNodeRadius(n);
  }



  // append patterns for node icons
  node_patterns = svg.select("#node_pattern_defs").selectAll("pattern")
    .data(node_types_data)
    .enter()
    .append("pattern")
      .attr("id", function(d) { return d.id; })
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");

  // add circles to node patterns
  node_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", function(d) { return d.fill_color; });

  // add images to node patterns
  node_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", function(d) { return d.image; });



  // append patterns for link icons
  link_patterns = svg.select("#link_pattern_defs").selectAll("pattern")
    .data(link_types_data)
    .enter()
    .append("pattern")
      .attr("id", function(d) { return d.id; })
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");

  // add circles to link patterns
  link_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", "black");

  // add images to link patterns
  link_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", function(d) { return d.image; });



  // append patterns for use icons
  use_patterns = svg.select("#use_pattern_defs").selectAll("pattern")
    .data(use_types_data)
    .enter()
    .append("pattern")
      .attr("id", function(d) { return d.id; })
      .attr("width", "1")
      .attr("height", "1")
      .attr("patternContentUnits", "objectBoundingBox");

  // add circles to use patterns
  use_patterns.append("circle")
    .attr("cx", ".5")
    .attr("cy", ".5")
    .attr("r", ".5")
    .attr("fill", function(d) { return d.fill_color; });

  // add images to use patterns
  use_patterns.append("image")
    .attr("x", ".2")
    .attr("y", ".2")
    .attr("width", ".6")
    .attr("height", ".6")
    .attr("href", function(d) { return d.image; });



  // append circles for layers
  for(let i = 3; i > 0; i--)
  {
    g.append("circle")
      .attr("r", layer_outline_radii[i])
      .attr("fill", colors_data.layer_fill)
      .attr("stroke", colors_data.layer_outline)
      .attr("stroke-width", dimensions_data.layer_outline_width);
  }



  // append links
  links = g.selectAll(".link")
    .data(links_data)
    .enter().append("g")
      .classed("link", true)
      .attr("transform", function(d)
      {
        let s = getNodeById(d.source);
        return "translate(" + s.x + "," + s.y + ")";
      });

  // add lines to links
  links_polylines = links.append("polyline")
    .attr("points", createLinkPolylineFromLink)
    .attr("transform", function(d) { return "rotate(" + getLinkRotationDegrees(d) + ")"; })
    .attr("fill", getLinkFillColor)
    .attr("stroke", getLinkOutlineColor)
    .attr("stroke-width", dimensions_data.link_outline_width);

  // mouse interactions for links
  links_polylines
    // display more information when the cursor hovers over links
    .on("mouseenter", function(d) { onMouseEnter({type:element_types.LINK, data:d, selection:d3.select(this)}); })
    // hide information when the cursor leaves a link
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.LINK, data:d, selection:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.LINK, data:d, selection:d3.select(this)}); });



  // append nodes
  nodes = g.selectAll(".node")
    .data(nodes_data)
    .enter().append("g")
      .classed("node", true)
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

  // add circles to nodes
  nodes_circles = nodes.append("circle")
    .attr("r", getNodeRadius)
    .attr("fill", getNodePattern)
    .attr("stroke", getNodeOutlineColor)
    .attr("stroke-width", dimensions_data.node_outline_width);

  // mouse interactions for nodes
  nodes_circles
    // display more information in the node sidebar when the cursor hovers over nodes
    .on("mouseenter", function(d) { onMouseEnter({type:element_types.NODE, data:d, selection:d3.select(this)}); })
    // update the node sidebar when the cursor leaves a node
    .on("mouseleave", function(d) { onMouseLeave({type:element_types.NODE, data:d, selection:d3.select(this)}); })
    // retain focus on an element when it is clicked
    .on("click", function(d) { onClick({type:element_types.NODE, data:d, selection:d3.select(this)}); });
}



// load data from .json files
d3.json("data/policies/steam.json").then(function(policy_encoding_data)
{
  d3.json("data/appearance.json").then(function(appearance_data)
  {
    // copy data from policy encoding .json file
    title = policy_encoding_data.title;
    intro_text = policy_encoding_data.intro_text;
    nodes_data = policy_encoding_data.nodes;
    node_types_data = policy_encoding_data.node_types;
    link_types_data = policy_encoding_data.link_types;
    use_types_data = policy_encoding_data.use_types;

    // copy data from appearance .json file
    colors_data = appearance_data.colors;
    dimensions_data = appearance_data.dimensions;

    main();
  });
});

</script>

</body>
</html>
